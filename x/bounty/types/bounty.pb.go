// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shentu/bounty/v1/bounty.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ProgramStatus int32

const (
	ProgramStatusInactive ProgramStatus = 0
	ProgramStatusActive   ProgramStatus = 1
	ProgramStatusClosed   ProgramStatus = 2
)

var ProgramStatus_name = map[int32]string{
	0: "PROGRAM_STATUS_INACTIVE",
	1: "PROGRAM_STATUS_ACTIVE",
	2: "PROGRAM_STATUS_CLOSED",
}

var ProgramStatus_value = map[string]int32{
	"PROGRAM_STATUS_INACTIVE": 0,
	"PROGRAM_STATUS_ACTIVE":   1,
	"PROGRAM_STATUS_CLOSED":   2,
}

func (x ProgramStatus) String() string {
	return proto.EnumName(ProgramStatus_name, int32(x))
}

func (ProgramStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{0}
}

type SeverityLevel int32

const (
	Unspecified   SeverityLevel = 0
	Critical      SeverityLevel = 1
	High          SeverityLevel = 2
	Medium        SeverityLevel = 3
	Low           SeverityLevel = 4
	Informational SeverityLevel = 5
)

var SeverityLevel_name = map[int32]string{
	0: "SEVERITY_LEVEL_UNSPECIFIED",
	1: "SEVERITY_LEVEL_CRITICAL",
	2: "SEVERITY_LEVEL_HIGH",
	3: "SEVERITY_LEVEL_MEDIUM",
	4: "SEVERITY_LEVEL_LOW",
	5: "SEVERITY_LEVEL_INFORMATIONAL",
}

var SeverityLevel_value = map[string]int32{
	"SEVERITY_LEVEL_UNSPECIFIED":   0,
	"SEVERITY_LEVEL_CRITICAL":      1,
	"SEVERITY_LEVEL_HIGH":          2,
	"SEVERITY_LEVEL_MEDIUM":        3,
	"SEVERITY_LEVEL_LOW":           4,
	"SEVERITY_LEVEL_INFORMATIONAL": 5,
}

func (x SeverityLevel) String() string {
	return proto.EnumName(SeverityLevel_name, int32(x))
}

func (SeverityLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{1}
}

type FindingStatus int32

const (
	FindingStatusSubmitted FindingStatus = 0
	FindingStatusActive    FindingStatus = 1
	FindingStatusConfirmed FindingStatus = 2
	FindingStatusPaid      FindingStatus = 3
	FindingStatusClosed    FindingStatus = 4
)

var FindingStatus_name = map[int32]string{
	0: "FINDING_STATUS_SUBMITTED",
	1: "FINDING_STATUS_ACTIVE",
	2: "FINDING_STATUS_CONFIRMED",
	3: "FINDING_STATUS_PAID",
	4: "FINDING_STATUS_CLOSED",
}

var FindingStatus_value = map[string]int32{
	"FINDING_STATUS_SUBMITTED": 0,
	"FINDING_STATUS_ACTIVE":    1,
	"FINDING_STATUS_CONFIRMED": 2,
	"FINDING_STATUS_PAID":      3,
	"FINDING_STATUS_CLOSED":    4,
}

func (x FindingStatus) String() string {
	return proto.EnumName(FindingStatus_name, int32(x))
}

func (FindingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{2}
}

type TheoremStatus int32

const (
	// default theorem status.
	TheoremStatus_THEOREM_STATUS_UNSPECIFIED TheoremStatus = 0
	// theorem status during the grant period.
	TheoremStatus_THEOREM_STATUS_GRANT_PERIOD TheoremStatus = 1
	// theorem status during the proof period.
	TheoremStatus_THEOREM_STATUS_PROOF_PERIOD TheoremStatus = 2
	// theorem that has passed.
	TheoremStatus_THEOREM_STATUS_PASSED TheoremStatus = 3
	// theorem that has closed.
	TheoremStatus_THEOREM_STATUS_CLOSED TheoremStatus = 4
)

var TheoremStatus_name = map[int32]string{
	0: "THEOREM_STATUS_UNSPECIFIED",
	1: "THEOREM_STATUS_GRANT_PERIOD",
	2: "THEOREM_STATUS_PROOF_PERIOD",
	3: "THEOREM_STATUS_PASSED",
	4: "THEOREM_STATUS_CLOSED",
}

var TheoremStatus_value = map[string]int32{
	"THEOREM_STATUS_UNSPECIFIED":  0,
	"THEOREM_STATUS_GRANT_PERIOD": 1,
	"THEOREM_STATUS_PROOF_PERIOD": 2,
	"THEOREM_STATUS_PASSED":       3,
	"THEOREM_STATUS_CLOSED":       4,
}

func (x TheoremStatus) String() string {
	return proto.EnumName(TheoremStatus_name, int32(x))
}

func (TheoremStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{3}
}

type ProofStatus int32

const (
	// default proof status.
	ProofStatus_PROOF_STATUS_UNSPECIFIED ProofStatus = 0
	// proof status during the creation period.
	ProofStatus_PROOF_STATUS_HASH_LOCK_PERIOD ProofStatus = 1
	// proof status during the upload proof period.
	ProofStatus_PROOF_STATUS_HASH_PROOF_PERIOD ProofStatus = 2
	// theorem that has passed.
	ProofStatus_PROOF_STATUS_PASSED ProofStatus = 3
	// theorem that has failed.
	ProofStatus_PROOF_STATUS_FAILED ProofStatus = 4
	// theorem that has timeout.
	ProofStatus_PROOF_STATUS_TIMEOUT ProofStatus = 5
)

var ProofStatus_name = map[int32]string{
	0: "PROOF_STATUS_UNSPECIFIED",
	1: "PROOF_STATUS_HASH_LOCK_PERIOD",
	2: "PROOF_STATUS_HASH_PROOF_PERIOD",
	3: "PROOF_STATUS_PASSED",
	4: "PROOF_STATUS_FAILED",
	5: "PROOF_STATUS_TIMEOUT",
}

var ProofStatus_value = map[string]int32{
	"PROOF_STATUS_UNSPECIFIED":       0,
	"PROOF_STATUS_HASH_LOCK_PERIOD":  1,
	"PROOF_STATUS_HASH_PROOF_PERIOD": 2,
	"PROOF_STATUS_PASSED":            3,
	"PROOF_STATUS_FAILED":            4,
	"PROOF_STATUS_TIMEOUT":           5,
}

func (x ProofStatus) String() string {
	return proto.EnumName(ProofStatus_name, int32(x))
}

func (ProofStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{4}
}

type Program struct {
	ProgramId string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty" yaml:"program_id"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
	// JSON by ProgramDetail
	Detail       string        `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	AdminAddress string        `protobuf:"bytes,4,opt,name=admin_address,json=adminAddress,proto3" json:"admin_address,omitempty" yaml:"admin_address"`
	Status       ProgramStatus `protobuf:"varint,5,opt,name=status,proto3,enum=shentu.bounty.v1.ProgramStatus" json:"status,omitempty" yaml:"status"`
	CreateTime   time.Time     `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time" yaml:"create_time"`
}

func (m *Program) Reset()         { *m = Program{} }
func (m *Program) String() string { return proto.CompactTextString(m) }
func (*Program) ProtoMessage()    {}
func (*Program) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{0}
}
func (m *Program) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Program) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Program.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Program) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Program.Merge(m, src)
}
func (m *Program) XXX_Size() int {
	return m.Size()
}
func (m *Program) XXX_DiscardUnknown() {
	xxx_messageInfo_Program.DiscardUnknown(m)
}

var xxx_messageInfo_Program proto.InternalMessageInfo

type Finding struct {
	ProgramId      string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty" yaml:"program_id"`
	FindingId      string `protobuf:"bytes,2,opt,name=finding_id,json=findingId,proto3" json:"finding_id,omitempty" yaml:"finding_id"`
	Title          string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Description    string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	ProofOfConcept string `protobuf:"bytes,5,opt,name=proof_of_concept,json=proofOfConcept,proto3" json:"proof_of_concept,omitempty" yaml:"proof_of_concept"`
	// hash(description + proof_of_concept + submitter)
	FindingHash      string        `protobuf:"bytes,6,opt,name=finding_hash,json=findingHash,proto3" json:"finding_hash,omitempty" yaml:"finding_hash"`
	SubmitterAddress string        `protobuf:"bytes,7,opt,name=submitter_address,json=submitterAddress,proto3" json:"submitter_address,omitempty" yaml:"submitter_address"`
	SeverityLevel    SeverityLevel `protobuf:"varint,8,opt,name=severity_level,json=severityLevel,proto3,enum=shentu.bounty.v1.SeverityLevel" json:"severity_level,omitempty" yaml:"severity_level"`
	Status           FindingStatus `protobuf:"varint,9,opt,name=status,proto3,enum=shentu.bounty.v1.FindingStatus" json:"status,omitempty" yaml:"status"`
	// JSON by FindingDetail
	Detail      string    `protobuf:"bytes,10,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	PaymentHash string    `protobuf:"bytes,11,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty" yaml:"payment_hash"`
	CreateTime  time.Time `protobuf:"bytes,12,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time" yaml:"create_time"`
}

func (m *Finding) Reset()         { *m = Finding{} }
func (m *Finding) String() string { return proto.CompactTextString(m) }
func (*Finding) ProtoMessage()    {}
func (*Finding) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{1}
}
func (m *Finding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Finding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Finding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Finding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Finding.Merge(m, src)
}
func (m *Finding) XXX_Size() int {
	return m.Size()
}
func (m *Finding) XXX_DiscardUnknown() {
	xxx_messageInfo_Finding.DiscardUnknown(m)
}

var xxx_messageInfo_Finding proto.InternalMessageInfo

type ProgramFingerprint struct {
	ProgramId string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"id" yaml:"id"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
	// JSON by ProgramDetail
	Detail       string        `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	AdminAddress string        `protobuf:"bytes,4,opt,name=admin_address,json=adminAddress,proto3" json:"admin_address,omitempty" yaml:"admin_address"`
	Status       ProgramStatus `protobuf:"varint,5,opt,name=status,proto3,enum=shentu.bounty.v1.ProgramStatus" json:"status,omitempty" yaml:"status"`
}

func (m *ProgramFingerprint) Reset()         { *m = ProgramFingerprint{} }
func (m *ProgramFingerprint) String() string { return proto.CompactTextString(m) }
func (*ProgramFingerprint) ProtoMessage()    {}
func (*ProgramFingerprint) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{2}
}
func (m *ProgramFingerprint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProgramFingerprint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProgramFingerprint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProgramFingerprint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProgramFingerprint.Merge(m, src)
}
func (m *ProgramFingerprint) XXX_Size() int {
	return m.Size()
}
func (m *ProgramFingerprint) XXX_DiscardUnknown() {
	xxx_messageInfo_ProgramFingerprint.DiscardUnknown(m)
}

var xxx_messageInfo_ProgramFingerprint proto.InternalMessageInfo

type FindingFingerprint struct {
	ProgramId string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty" yaml:"program_id"`
	FindingId string `protobuf:"bytes,2,opt,name=finding_id,json=findingId,proto3" json:"id" yaml:"id"`
	Title     string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// hash(description + proof_of_concept + submitter)
	FindingHash   string        `protobuf:"bytes,4,opt,name=finding_hash,json=findingHash,proto3" json:"finding_hash,omitempty" yaml:"finding_hash"`
	SeverityLevel SeverityLevel `protobuf:"varint,5,opt,name=severity_level,json=severityLevel,proto3,enum=shentu.bounty.v1.SeverityLevel" json:"severity_level,omitempty" yaml:"severity_level"`
	Status        FindingStatus `protobuf:"varint,6,opt,name=status,proto3,enum=shentu.bounty.v1.FindingStatus" json:"status,omitempty" yaml:"status"`
	// JSON by FindingDetail
	Detail      string `protobuf:"bytes,7,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	PaymentHash string `protobuf:"bytes,8,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty" yaml:"payment_hash"`
}

func (m *FindingFingerprint) Reset()         { *m = FindingFingerprint{} }
func (m *FindingFingerprint) String() string { return proto.CompactTextString(m) }
func (*FindingFingerprint) ProtoMessage()    {}
func (*FindingFingerprint) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{3}
}
func (m *FindingFingerprint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindingFingerprint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindingFingerprint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindingFingerprint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindingFingerprint.Merge(m, src)
}
func (m *FindingFingerprint) XXX_Size() int {
	return m.Size()
}
func (m *FindingFingerprint) XXX_DiscardUnknown() {
	xxx_messageInfo_FindingFingerprint.DiscardUnknown(m)
}

var xxx_messageInfo_FindingFingerprint proto.InternalMessageInfo

// Theorem defines the core field members of an openmath theorem.
type Theorem struct {
	// id defines the unique id of the theorem.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// title is the title of the theorem
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// description is the description of the theorem
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// code is a summary of the theorem
	Code    string `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	ProofId string `protobuf:"bytes,5,opt,name=proof_id,json=proofId,proto3" json:"proof_id,omitempty"`
	// status defines the theorem status.
	Status TheoremStatus `protobuf:"varint,6,opt,name=status,proto3,enum=shentu.bounty.v1.TheoremStatus" json:"status,omitempty"`
	// submit_time is the time of theorem submission.
	SubmitTime *time.Time `protobuf:"bytes,7,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time,omitempty"`
	// submit_time is the time of theorem submission.
	GrantEndTime *time.Time `protobuf:"bytes,8,opt,name=grant_end_time,json=grantEndTime,proto3,stdtime" json:"grant_end_time,omitempty"`
	// voting_start_time is the starting time to submit proof of a theorem.
	ProofStartTime *time.Time `protobuf:"bytes,9,opt,name=proof_start_time,json=proofStartTime,proto3,stdtime" json:"proof_start_time,omitempty"`
	ProofEndTime   *time.Time `protobuf:"bytes,10,opt,name=proof_end_time,json=proofEndTime,proto3,stdtime" json:"proof_end_time,omitempty"`
	// total_deposit is the total grant on the theorem.
	TotalGrant []types1.Coin `protobuf:"bytes,11,rep,name=total_grant,json=totalGrant,proto3" json:"total_grant"`
	// proposer is the address of the theorem submitter
	Proposer string `protobuf:"bytes,12,opt,name=proposer,proto3" json:"proposer,omitempty"`
}

func (m *Theorem) Reset()         { *m = Theorem{} }
func (m *Theorem) String() string { return proto.CompactTextString(m) }
func (*Theorem) ProtoMessage()    {}
func (*Theorem) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{4}
}
func (m *Theorem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Theorem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Theorem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Theorem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Theorem.Merge(m, src)
}
func (m *Theorem) XXX_Size() int {
	return m.Size()
}
func (m *Theorem) XXX_DiscardUnknown() {
	xxx_messageInfo_Theorem.DiscardUnknown(m)
}

var xxx_messageInfo_Theorem proto.InternalMessageInfo

func (m *Theorem) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Theorem) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Theorem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Theorem) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Theorem) GetProofId() string {
	if m != nil {
		return m.ProofId
	}
	return ""
}

func (m *Theorem) GetStatus() TheoremStatus {
	if m != nil {
		return m.Status
	}
	return TheoremStatus_THEOREM_STATUS_UNSPECIFIED
}

func (m *Theorem) GetSubmitTime() *time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return nil
}

func (m *Theorem) GetGrantEndTime() *time.Time {
	if m != nil {
		return m.GrantEndTime
	}
	return nil
}

func (m *Theorem) GetProofStartTime() *time.Time {
	if m != nil {
		return m.ProofStartTime
	}
	return nil
}

func (m *Theorem) GetProofEndTime() *time.Time {
	if m != nil {
		return m.ProofEndTime
	}
	return nil
}

func (m *Theorem) GetTotalGrant() []types1.Coin {
	if m != nil {
		return m.TotalGrant
	}
	return nil
}

func (m *Theorem) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

type Proof struct {
	TheoremId uint64 `protobuf:"varint,1,opt,name=theorem_id,json=theoremId,proto3" json:"theorem_id,omitempty"`
	// id defines the unique id of the proof.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// proof_url is the proof data attached to the theorem stored in ipfs
	ProofContent string `protobuf:"bytes,3,opt,name=proof_content,json=proofContent,proto3" json:"proof_content,omitempty"`
	// status defines the theorem status.
	Status ProofStatus `protobuf:"varint,4,opt,name=status,proto3,enum=shentu.bounty.v1.ProofStatus" json:"status,omitempty"`
	// submit_time is the time of proof submission.
	SubmitTime *time.Time `protobuf:"bytes,5,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time,omitempty"`
	// prover is the address of the proof submitter
	Prover  string      `protobuf:"bytes,6,opt,name=prover,proto3" json:"prover,omitempty"`
	Deposit types1.Coin `protobuf:"bytes,7,opt,name=Deposit,proto3" json:"Deposit"`
}

func (m *Proof) Reset()         { *m = Proof{} }
func (m *Proof) String() string { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()    {}
func (*Proof) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{5}
}
func (m *Proof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proof.Merge(m, src)
}
func (m *Proof) XXX_Size() int {
	return m.Size()
}
func (m *Proof) XXX_DiscardUnknown() {
	xxx_messageInfo_Proof.DiscardUnknown(m)
}

var xxx_messageInfo_Proof proto.InternalMessageInfo

func (m *Proof) GetTheoremId() uint64 {
	if m != nil {
		return m.TheoremId
	}
	return 0
}

func (m *Proof) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Proof) GetProofContent() string {
	if m != nil {
		return m.ProofContent
	}
	return ""
}

func (m *Proof) GetStatus() ProofStatus {
	if m != nil {
		return m.Status
	}
	return ProofStatus_PROOF_STATUS_UNSPECIFIED
}

func (m *Proof) GetSubmitTime() *time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return nil
}

func (m *Proof) GetProver() string {
	if m != nil {
		return m.Prover
	}
	return ""
}

func (m *Proof) GetDeposit() types1.Coin {
	if m != nil {
		return m.Deposit
	}
	return types1.Coin{}
}

// Grant defines an amount granted by a grantor to an active theorem.
type Grant struct {
	// theorem_id defines the unique id of the theorem.
	TheoremsId uint64 `protobuf:"varint,1,opt,name=theorems_id,json=theoremsId,proto3" json:"theorems_id,omitempty"`
	// grantor defines the grant addresses.
	Grantor string `protobuf:"bytes,2,opt,name=grantor,proto3" json:"grantor,omitempty"`
	// amount to be deposited by the grantor.
	Amount []types1.Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *Grant) Reset()         { *m = Grant{} }
func (m *Grant) String() string { return proto.CompactTextString(m) }
func (*Grant) ProtoMessage()    {}
func (*Grant) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{6}
}
func (m *Grant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Grant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Grant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Grant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grant.Merge(m, src)
}
func (m *Grant) XXX_Size() int {
	return m.Size()
}
func (m *Grant) XXX_DiscardUnknown() {
	xxx_messageInfo_Grant.DiscardUnknown(m)
}

var xxx_messageInfo_Grant proto.InternalMessageInfo

func (m *Grant) GetTheoremsId() uint64 {
	if m != nil {
		return m.TheoremsId
	}
	return 0
}

func (m *Grant) GetGrantor() string {
	if m != nil {
		return m.Grantor
	}
	return ""
}

func (m *Grant) GetAmount() []types1.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

type Params struct {
	// Minimum grant for a theorem to enter the proof period.
	MinGrant []types1.Coin `protobuf:"bytes,1,rep,name=min_grant,json=minGrant,proto3" json:"min_grant"`
	// Maximum period for Shentu holders to grant on a theorem. Initial value: 2 weeks.
	MaxGrantPeriod *time.Duration `protobuf:"bytes,2,opt,name=max_grant_period,json=maxGrantPeriod,proto3,stdduration" json:"max_grant_period,omitempty"`
	// Duration of the proof period.
	ProofPeriod *time.Duration `protobuf:"bytes,3,opt,name=proof_period,json=proofPeriod,proto3,stdduration" json:"proof_period,omitempty"`
	// Duration of the proof lock period. 10min
	ProofHashLockPeriod *time.Duration `protobuf:"bytes,4,opt,name=proof_hash_lock_period,json=proofHashLockPeriod,proto3,stdduration" json:"proof_hash_lock_period,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{7}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMinGrant() []types1.Coin {
	if m != nil {
		return m.MinGrant
	}
	return nil
}

func (m *Params) GetMaxGrantPeriod() *time.Duration {
	if m != nil {
		return m.MaxGrantPeriod
	}
	return nil
}

func (m *Params) GetProofPeriod() *time.Duration {
	if m != nil {
		return m.ProofPeriod
	}
	return nil
}

func (m *Params) GetProofHashLockPeriod() *time.Duration {
	if m != nil {
		return m.ProofHashLockPeriod
	}
	return nil
}

func init() {
	proto.RegisterEnum("shentu.bounty.v1.ProgramStatus", ProgramStatus_name, ProgramStatus_value)
	proto.RegisterEnum("shentu.bounty.v1.SeverityLevel", SeverityLevel_name, SeverityLevel_value)
	proto.RegisterEnum("shentu.bounty.v1.FindingStatus", FindingStatus_name, FindingStatus_value)
	proto.RegisterEnum("shentu.bounty.v1.TheoremStatus", TheoremStatus_name, TheoremStatus_value)
	proto.RegisterEnum("shentu.bounty.v1.ProofStatus", ProofStatus_name, ProofStatus_value)
	proto.RegisterType((*Program)(nil), "shentu.bounty.v1.Program")
	proto.RegisterType((*Finding)(nil), "shentu.bounty.v1.Finding")
	proto.RegisterType((*ProgramFingerprint)(nil), "shentu.bounty.v1.ProgramFingerprint")
	proto.RegisterType((*FindingFingerprint)(nil), "shentu.bounty.v1.FindingFingerprint")
	proto.RegisterType((*Theorem)(nil), "shentu.bounty.v1.Theorem")
	proto.RegisterType((*Proof)(nil), "shentu.bounty.v1.Proof")
	proto.RegisterType((*Grant)(nil), "shentu.bounty.v1.Grant")
	proto.RegisterType((*Params)(nil), "shentu.bounty.v1.Params")
}

func init() { proto.RegisterFile("shentu/bounty/v1/bounty.proto", fileDescriptor_36e6d679af1b94c6) }

var fileDescriptor_36e6d679af1b94c6 = []byte{
	// 1738 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0x41, 0x6f, 0x23, 0x49,
	0x15, 0x76, 0xdb, 0x8e, 0x1d, 0x3f, 0xc7, 0xb3, 0x4e, 0x25, 0x99, 0x38, 0xde, 0x19, 0xb7, 0xb7,
	0x57, 0x48, 0xb3, 0x23, 0x61, 0x93, 0xec, 0x00, 0xab, 0x11, 0x20, 0xd9, 0x8e, 0x9d, 0xf4, 0xae,
	0x13, 0x5b, 0x6d, 0x67, 0x10, 0x70, 0x68, 0x75, 0xdc, 0x65, 0xa7, 0xb5, 0xee, 0x2e, 0xab, 0xbb,
	0x1d, 0x26, 0x47, 0x6e, 0x2b, 0x9f, 0x86, 0x1b, 0x42, 0xb2, 0xb4, 0x88, 0x03, 0x5c, 0x90, 0xf6,
	0x00, 0x57, 0xae, 0xec, 0x71, 0x85, 0x84, 0xc4, 0xc9, 0xa0, 0x99, 0x03, 0x88, 0x13, 0xf2, 0x2f,
	0x40, 0x5d, 0x55, 0xed, 0xb8, 0x7b, 0x1c, 0x92, 0x19, 0xb1, 0x27, 0x2e, 0x51, 0x57, 0xbd, 0xf7,
	0x7d, 0xfd, 0xea, 0xbd, 0xef, 0xbd, 0x6a, 0x07, 0x1e, 0x3a, 0x17, 0xd8, 0x72, 0xc7, 0xe5, 0x73,
	0x32, 0xb6, 0xdc, 0xab, 0xf2, 0xe5, 0x3e, 0x7f, 0x2a, 0x8d, 0x6c, 0xe2, 0x12, 0x94, 0x65, 0xe6,
	0x12, 0xdf, 0xbc, 0xdc, 0xcf, 0x6f, 0x0f, 0xc8, 0x80, 0x50, 0x63, 0xd9, 0x7b, 0x62, 0x7e, 0x79,
	0x71, 0x40, 0xc8, 0x60, 0x88, 0xcb, 0x74, 0x75, 0x3e, 0xee, 0x97, 0x5d, 0xc3, 0xc4, 0x8e, 0xab,
	0x99, 0x23, 0xee, 0x50, 0xe8, 0x11, 0xc7, 0x24, 0x4e, 0xf9, 0x5c, 0x73, 0x70, 0xf9, 0x72, 0xff,
	0x1c, 0xbb, 0xda, 0x7e, 0xb9, 0x47, 0x0c, 0x8b, 0xdb, 0xf7, 0x98, 0x5d, 0x65, 0xcc, 0x6c, 0xe1,
	0x9b, 0xc2, 0xdc, 0x9a, 0x75, 0xe5, 0xb3, 0x86, 0x4d, 0xfa, 0xd8, 0xd6, 0x5c, 0x83, 0xf8, 0xac,
	0x9b, 0x9a, 0x69, 0x58, 0xa4, 0x4c, 0xff, 0xb2, 0x2d, 0xe9, 0x67, 0x31, 0x48, 0xb6, 0x6d, 0x32,
	0xb0, 0x35, 0x13, 0x3d, 0x01, 0x18, 0xb1, 0x47, 0xd5, 0xd0, 0x73, 0x42, 0x51, 0x78, 0x94, 0xaa,
	0xee, 0xcc, 0x67, 0xe2, 0xe6, 0x95, 0x66, 0x0e, 0x9f, 0x4a, 0xd7, 0x36, 0x49, 0x49, 0xf1, 0x85,
	0xac, 0xa3, 0xf7, 0x21, 0x6e, 0x69, 0x26, 0xce, 0x45, 0xa9, 0xff, 0x3b, 0xf3, 0x99, 0x98, 0x66,
	0xfe, 0xde, 0xae, 0xa4, 0x50, 0x23, 0xfa, 0x00, 0x12, 0x3a, 0x76, 0x35, 0x63, 0x98, 0x8b, 0x51,
	0xb7, 0xcd, 0xf9, 0x4c, 0xcc, 0x30, 0x37, 0xb6, 0x2f, 0x29, 0xdc, 0x01, 0x7d, 0x1f, 0x32, 0x9a,
	0x6e, 0x1a, 0x96, 0xaa, 0xe9, 0xba, 0x8d, 0x1d, 0x27, 0x17, 0xa7, 0x88, 0xdc, 0x7c, 0x26, 0x6e,
	0x33, 0x44, 0xc0, 0x2c, 0x29, 0x1b, 0x74, 0x5d, 0x61, 0x4b, 0xf4, 0x31, 0x24, 0x1c, 0x57, 0x73,
	0xc7, 0x4e, 0x6e, 0xad, 0x28, 0x3c, 0xba, 0x77, 0x20, 0x96, 0xc2, 0x35, 0x2b, 0xf1, 0xf3, 0x76,
	0xa8, 0xdb, 0x72, 0x28, 0x0c, 0x28, 0x29, 0x9c, 0x01, 0xfd, 0x04, 0xd2, 0x3d, 0x1b, 0x6b, 0x2e,
	0x56, 0xbd, 0xfa, 0xe5, 0x12, 0x45, 0xe1, 0x51, 0xfa, 0x20, 0x5f, 0x62, 0x59, 0x2e, 0xf9, 0x59,
	0x2e, 0x75, 0xfd, 0xe2, 0x56, 0x0b, 0x5f, 0xce, 0xc4, 0xc8, 0x7c, 0x26, 0x22, 0xc6, 0xb7, 0x04,
	0x96, 0x5e, 0xfc, 0x4d, 0x14, 0x14, 0x60, 0x3b, 0x1e, 0xe0, 0xe9, 0xfa, 0x67, 0x9f, 0x8b, 0x91,
	0x7f, 0x7e, 0x2e, 0x46, 0xa4, 0x17, 0x09, 0x48, 0x36, 0x0c, 0x4b, 0x37, 0xac, 0xc1, 0x5b, 0xd6,
	0xe0, 0x09, 0x40, 0x9f, 0x11, 0x78, 0xa8, 0x68, 0x18, 0x75, 0x6d, 0x93, 0x94, 0x14, 0x5f, 0xc8,
	0x3a, 0xda, 0x86, 0x35, 0xd7, 0x70, 0x87, 0x98, 0xd5, 0x44, 0x61, 0x0b, 0xf4, 0x11, 0xa4, 0x75,
	0xec, 0xf4, 0x6c, 0x63, 0xe4, 0x29, 0x87, 0x67, 0xff, 0xfe, 0xf5, 0xa1, 0x96, 0x8c, 0x92, 0xb2,
	0xec, 0x8a, 0xea, 0x90, 0x1d, 0xd9, 0x84, 0xf4, 0x55, 0xd2, 0x57, 0x7b, 0xc4, 0xea, 0xe1, 0x91,
	0x4b, 0x8b, 0x90, 0xaa, 0xbe, 0x3b, 0x9f, 0x89, 0xbb, 0x8b, 0x13, 0x04, 0x3c, 0x24, 0xe5, 0x1e,
	0xdd, 0x6a, 0xf5, 0x6b, 0x6c, 0x03, 0x3d, 0x85, 0x0d, 0x3f, 0xe0, 0x0b, 0xcd, 0xb9, 0xa0, 0x69,
	0x4f, 0x55, 0x77, 0xe7, 0x33, 0x71, 0x2b, 0x78, 0x1c, 0xcf, 0x2a, 0x29, 0x69, 0xbe, 0x3c, 0xd6,
	0x9c, 0x0b, 0x24, 0xc3, 0xa6, 0x33, 0x3e, 0x37, 0x0d, 0xd7, 0xc5, 0xf6, 0x42, 0x40, 0x49, 0x4a,
	0xf0, 0x60, 0x3e, 0x13, 0x73, 0xbc, 0xce, 0x61, 0x17, 0x49, 0xc9, 0x2e, 0xf6, 0x7c, 0x21, 0x69,
	0x70, 0xcf, 0xc1, 0x97, 0xd8, 0x36, 0xdc, 0x2b, 0x75, 0x88, 0x2f, 0xf1, 0x30, 0xb7, 0x7e, 0x93,
	0xa0, 0x3a, 0xdc, 0xaf, 0xe9, 0xb9, 0x55, 0xf7, 0xe6, 0x33, 0x71, 0x87, 0xbf, 0x28, 0x40, 0x20,
	0x29, 0x19, 0x67, 0xd9, 0x73, 0x49, 0xab, 0xa9, 0x9b, 0xa8, 0xb9, 0x2e, 0x6e, 0xd7, 0xea, 0x75,
	0x87, 0xc1, 0x6d, 0x1d, 0xf6, 0x14, 0x36, 0x46, 0xda, 0x95, 0x89, 0x2d, 0x97, 0x25, 0x38, 0x1d,
	0x4e, 0xf0, 0xb2, 0x55, 0x52, 0xd2, 0x7c, 0x49, 0x13, 0x1c, 0x6a, 0x89, 0x8d, 0xaf, 0xa9, 0x25,
	0x7e, 0x17, 0x05, 0xc4, 0xdb, 0xb4, 0x61, 0x58, 0x03, 0x6c, 0x8f, 0x6c, 0xc3, 0x72, 0xd1, 0xc1,
	0x8a, 0xee, 0xd8, 0xfa, 0xd7, 0x4c, 0x8c, 0x1a, 0xfa, 0x7c, 0x26, 0xa6, 0xd8, 0x2b, 0xfe, 0x6f,
	0xe6, 0xd3, 0x52, 0xbe, 0xfe, 0x1d, 0x03, 0xc4, 0xa5, 0xb2, 0x9c, 0xaf, 0xb7, 0x9b, 0x26, 0x07,
	0x2b, 0xa6, 0xc9, 0xea, 0x2c, 0xdf, 0x36, 0x4b, 0xc2, 0xad, 0x1c, 0x7f, 0x83, 0x56, 0x7e, 0xbd,
	0xff, 0xd6, 0xbe, 0xbe, 0xfe, 0x4b, 0xfc, 0x0f, 0xfb, 0x2f, 0xf9, 0xa6, 0xfd, 0xb7, 0x7e, 0xf7,
	0xfe, 0x5b, 0x2a, 0xf9, 0x5f, 0xe2, 0x90, 0xec, 0x5e, 0x60, 0x62, 0x63, 0x13, 0xdd, 0x83, 0x28,
	0xaf, 0x6f, 0x5c, 0x89, 0x1a, 0x4b, 0xd5, 0x88, 0x2e, 0x57, 0xa3, 0x18, 0x9c, 0xec, 0xac, 0x52,
	0x81, 0x09, 0x8e, 0x20, 0xde, 0x23, 0x3a, 0x66, 0x75, 0x52, 0xe8, 0x33, 0xda, 0x83, 0x75, 0x36,
	0xb3, 0x0d, 0x9d, 0x4d, 0x73, 0x25, 0x49, 0xd7, 0xb2, 0x8e, 0xbe, 0x7b, 0x7b, 0xfe, 0x78, 0x84,
	0x2c, 0x7f, 0x8b, 0x64, 0x55, 0x20, 0xcd, 0xe6, 0x2d, 0x9b, 0x22, 0xc9, 0x5b, 0xa7, 0x48, 0x9c,
	0xcd, 0x0a, 0x06, 0xf2, 0xb6, 0x51, 0x03, 0xee, 0x0d, 0x6c, 0xcd, 0x72, 0x55, 0x6c, 0xe9, 0x8c,
	0x65, 0xfd, 0x8e, 0x2c, 0x1b, 0x14, 0x57, 0xb7, 0x74, 0xca, 0xf3, 0xb1, 0x7f, 0x69, 0x39, 0xae,
	0x66, 0xf3, 0x78, 0x52, 0x77, 0x64, 0x62, 0x37, 0x57, 0xc7, 0x03, 0xfa, 0x31, 0x31, 0xae, 0x45,
	0x4c, 0x70, 0xd7, 0x98, 0x28, 0xce, 0x8f, 0xa9, 0x0e, 0x69, 0x97, 0xb8, 0xda, 0x50, 0xa5, 0x91,
	0xe6, 0xd2, 0xc5, 0xd8, 0xa3, 0xf4, 0xc1, 0x5e, 0x89, 0x7f, 0x06, 0x7a, 0xdf, 0x8c, 0x25, 0xfe,
	0xcd, 0x58, 0xaa, 0x11, 0xc3, 0xaa, 0xa6, 0xbc, 0x19, 0xfb, 0xdb, 0x7f, 0x7c, 0xf1, 0x58, 0x50,
	0x80, 0x02, 0x8f, 0x3c, 0x1c, 0x7a, 0x42, 0x2b, 0x37, 0x22, 0x0e, 0xb6, 0xe9, 0xa0, 0x4e, 0x55,
	0x73, 0x7f, 0xfe, 0xfd, 0x37, 0xb7, 0x39, 0x0d, 0x1f, 0x48, 0x1d, 0xd7, 0x36, 0xac, 0x81, 0xb2,
	0xf0, 0x94, 0xfe, 0x14, 0x85, 0xb5, 0xb6, 0x17, 0x0d, 0x7a, 0x08, 0xe0, 0xb2, 0xf2, 0xa9, 0x0b,
	0x75, 0xa5, 0xf8, 0x8e, 0xac, 0x73, 0xd1, 0x31, 0x85, 0x79, 0xa2, 0x7b, 0x1f, 0x32, 0xec, 0xf4,
	0x3d, 0x62, 0xb9, 0xd8, 0x72, 0xb9, 0xc0, 0xd8, 0xd1, 0x6a, 0x6c, 0x0f, 0x7d, 0x7b, 0x21, 0x99,
	0x38, 0x95, 0xcc, 0xc3, 0x95, 0xe3, 0x8f, 0x26, 0xf5, 0xbf, 0x08, 0x66, 0xed, 0x2d, 0x04, 0xf3,
	0x2d, 0x48, 0x8c, 0x6c, 0x72, 0x89, 0x6d, 0xfe, 0x41, 0x71, 0x73, 0x2e, 0xb8, 0x1f, 0xfa, 0x01,
	0x24, 0x0f, 0xf1, 0x88, 0x38, 0x86, 0xcb, 0x15, 0x7a, 0xb7, 0x12, 0xf8, 0x20, 0xe9, 0x97, 0x02,
	0xac, 0xb1, 0x4a, 0x88, 0x90, 0xe6, 0x79, 0x73, 0xae, 0x53, 0xe9, 0x27, 0xd7, 0xa1, 0x23, 0x37,
	0x49, 0x6b, 0x4d, 0x6c, 0x3e, 0x6f, 0x6f, 0x8e, 0xce, 0x77, 0x44, 0xdf, 0x83, 0x84, 0x66, 0x7a,
	0x59, 0xcb, 0xc5, 0xde, 0x40, 0x20, 0x1c, 0x23, 0x7d, 0x11, 0x85, 0x44, 0x5b, 0xb3, 0x35, 0xd3,
	0x4b, 0x6e, 0xca, 0xbb, 0xb0, 0x98, 0xd8, 0x84, 0x37, 0xe0, 0x5a, 0x37, 0x0d, 0x8b, 0x1d, 0x50,
	0x86, 0xac, 0xa9, 0x3d, 0x67, 0x14, 0xea, 0x08, 0xdb, 0x06, 0x61, 0xca, 0xf0, 0x98, 0xc2, 0x45,
	0x3a, 0xe4, 0x3f, 0x4a, 0xaa, 0xf1, 0x5f, 0xd0, 0x26, 0x32, 0xb5, 0xe7, 0x94, 0xa4, 0x4d, 0x61,
	0xa8, 0x0a, 0x4c, 0x31, 0x3e, 0x4d, 0xec, 0x6e, 0x34, 0x69, 0x0a, 0xe2, 0x1c, 0x5d, 0xb8, 0xcf,
	0x38, 0xbc, 0x09, 0xaa, 0x0e, 0x49, 0xef, 0x53, 0x9f, 0x2d, 0x7e, 0x37, 0xb6, 0x2d, 0x0a, 0xf7,
	0x26, 0x6e, 0x93, 0xf4, 0x3e, 0x65, 0xac, 0x8f, 0xff, 0x20, 0x40, 0x26, 0x70, 0x37, 0xa3, 0xef,
	0xc0, 0x6e, 0x5b, 0x69, 0x1d, 0x29, 0x95, 0x13, 0xb5, 0xd3, 0xad, 0x74, 0xcf, 0x3a, 0xaa, 0x7c,
	0x5a, 0xa9, 0x75, 0xe5, 0x67, 0xf5, 0x6c, 0x24, 0xbf, 0x37, 0x99, 0x16, 0x77, 0x02, 0xfe, 0xb2,
	0xa5, 0xf5, 0x5c, 0xe3, 0x12, 0xa3, 0x03, 0xd8, 0x09, 0xe1, 0x38, 0x4a, 0xc8, 0xef, 0x4e, 0xa6,
	0xc5, 0xad, 0x00, 0xaa, 0x72, 0x13, 0xa6, 0xd6, 0x6c, 0x75, 0xea, 0x87, 0xd9, 0xe8, 0x0a, 0x4c,
	0x6d, 0x48, 0x1c, 0xac, 0xe7, 0xe3, 0x9f, 0xfd, 0xba, 0x10, 0x79, 0xfc, 0xf3, 0x28, 0x64, 0x02,
	0x57, 0x24, 0x2a, 0x43, 0xbe, 0x53, 0x7f, 0x56, 0x57, 0xe4, 0xee, 0x8f, 0xd4, 0x66, 0xfd, 0x59,
	0xbd, 0xa9, 0x9e, 0x9d, 0x76, 0xda, 0xf5, 0x9a, 0xdc, 0x90, 0xeb, 0x87, 0xd9, 0x48, 0xfe, 0x9d,
	0xc9, 0xb4, 0x98, 0x3e, 0xb3, 0x9c, 0x11, 0xee, 0x19, 0x7d, 0x03, 0xeb, 0xe8, 0x03, 0xd8, 0x0d,
	0x01, 0x6a, 0x8a, 0xdc, 0x95, 0x6b, 0x95, 0x66, 0x56, 0xc8, 0x6f, 0x4c, 0xa6, 0xc5, 0xf5, 0x9a,
	0x6d, 0xb8, 0x46, 0x4f, 0x1b, 0xa2, 0xf7, 0x60, 0x2b, 0xe4, 0x7a, 0x2c, 0x1f, 0x1d, 0x67, 0xa3,
	0xf9, 0xf5, 0xc9, 0xb4, 0x18, 0x3f, 0x36, 0x06, 0x17, 0xe8, 0x1b, 0xb0, 0x13, 0x72, 0x39, 0xa9,
	0x1f, 0xca, 0x67, 0x27, 0xd9, 0x58, 0x1e, 0x26, 0xd3, 0x62, 0xe2, 0x04, 0xeb, 0xc6, 0xd8, 0x44,
	0x22, 0xa0, 0x90, 0x5b, 0xb3, 0xf5, 0xc3, 0x6c, 0x3c, 0x9f, 0x9c, 0x4c, 0x8b, 0xb1, 0x26, 0xf9,
	0x29, 0xfa, 0x10, 0x1e, 0x84, 0x1c, 0xe4, 0xd3, 0x46, 0x4b, 0x39, 0xa9, 0x74, 0xe5, 0xd6, 0x69,
	0xa5, 0x99, 0x5d, 0xcb, 0x6f, 0x4e, 0xa6, 0xc5, 0x8c, 0x6c, 0xf5, 0x89, 0x6d, 0xd2, 0xf2, 0x6a,
	0x43, 0x9e, 0x93, 0x5f, 0x45, 0x21, 0x13, 0xb8, 0xdb, 0xd1, 0x47, 0x90, 0x6b, 0xc8, 0xa7, 0x87,
	0xf2, 0xe9, 0x91, 0x9f, 0xdf, 0xce, 0x59, 0xf5, 0x44, 0xee, 0x76, 0x69, 0x46, 0xf2, 0x93, 0x69,
	0xf1, 0x7e, 0x00, 0xd0, 0xe1, 0x3f, 0x18, 0xbc, 0xe6, 0xdd, 0x09, 0x21, 0x83, 0xd5, 0x0c, 0xc0,
	0x78, 0x35, 0x5f, 0x7f, 0x5b, 0xad, 0x75, 0xda, 0x90, 0x95, 0x13, 0x5a, 0xd0, 0xd7, 0xdf, 0x56,
	0x23, 0x56, 0xdf, 0xb0, 0x4d, 0xac, 0xa3, 0x12, 0x6c, 0x85, 0x90, 0xed, 0x8a, 0x7c, 0x98, 0x8d,
	0xe5, 0x77, 0x26, 0xd3, 0xe2, 0x66, 0x00, 0xd4, 0xd6, 0x8c, 0x55, 0xd1, 0x71, 0xdd, 0xc4, 0x57,
	0x44, 0x17, 0xd0, 0xcd, 0x6f, 0x04, 0xc8, 0x04, 0xee, 0x6f, 0x54, 0x80, 0x7c, 0xf7, 0xb8, 0xde,
	0x52, 0xea, 0x0b, 0x0d, 0x06, 0x74, 0x83, 0x44, 0x78, 0x37, 0x64, 0x3f, 0x52, 0x2a, 0xa7, 0x5d,
	0xb5, 0x5d, 0x57, 0xe4, 0xd6, 0x61, 0x56, 0x58, 0xe1, 0xd0, 0x56, 0x5a, 0xad, 0x86, 0xef, 0x10,
	0x45, 0x7b, 0xb0, 0x13, 0x76, 0xa8, 0x74, 0xbc, 0x68, 0x63, 0x2b, 0x4c, 0xfe, 0x41, 0x1e, 0xff,
	0x51, 0x80, 0xf4, 0xd2, 0xb5, 0x81, 0x1e, 0x40, 0x8e, 0xf1, 0xae, 0x8c, 0xf2, 0x3d, 0x78, 0x18,
	0xb0, 0x1e, 0x57, 0x3a, 0xc7, 0x6a, 0xb3, 0x55, 0xfb, 0xe4, 0x3a, 0x4e, 0x09, 0x0a, 0xaf, 0xbb,
	0x84, 0x42, 0xdd, 0x85, 0xad, 0x80, 0xcf, 0x22, 0xd0, 0xb0, 0xa1, 0x51, 0x91, 0x9b, 0x5e, 0x98,
	0x28, 0x07, 0xdb, 0x01, 0x43, 0x57, 0x3e, 0xa9, 0xb7, 0xce, 0xba, 0xd9, 0xb5, 0xea, 0x27, 0x5f,
	0xbe, 0x2c, 0x08, 0x5f, 0xbd, 0x2c, 0x08, 0x7f, 0x7f, 0x59, 0x10, 0x5e, 0xbc, 0x2a, 0x44, 0xbe,
	0x7a, 0x55, 0x88, 0xfc, 0xf5, 0x55, 0x21, 0xf2, 0xe3, 0xfd, 0x81, 0xe1, 0x5e, 0x8c, 0xcf, 0x4b,
	0x3d, 0x62, 0x96, 0xd9, 0x55, 0xd9, 0x27, 0x63, 0x4b, 0xa7, 0x6a, 0xe6, 0x1b, 0xe5, 0xe7, 0xfe,
	0xff, 0xab, 0xdc, 0xab, 0x11, 0x76, 0xce, 0x13, 0x74, 0xaa, 0x7d, 0xf8, 0x9f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x9b, 0x6a, 0x70, 0x21, 0xcd, 0x12, 0x00, 0x00,
}

func (m *Program) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Program) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Program) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintBounty(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x32
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AdminAddress) > 0 {
		i -= len(m.AdminAddress)
		copy(dAtA[i:], m.AdminAddress)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.AdminAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Finding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Finding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Finding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintBounty(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x62
	if len(m.PaymentHash) > 0 {
		i -= len(m.PaymentHash)
		copy(dAtA[i:], m.PaymentHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.PaymentHash)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x52
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.SeverityLevel != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.SeverityLevel))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SubmitterAddress) > 0 {
		i -= len(m.SubmitterAddress)
		copy(dAtA[i:], m.SubmitterAddress)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.SubmitterAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FindingHash) > 0 {
		i -= len(m.FindingHash)
		copy(dAtA[i:], m.FindingHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofOfConcept) > 0 {
		i -= len(m.ProofOfConcept)
		copy(dAtA[i:], m.ProofOfConcept)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProofOfConcept)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FindingId) > 0 {
		i -= len(m.FindingId)
		copy(dAtA[i:], m.FindingId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProgramFingerprint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgramFingerprint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProgramFingerprint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AdminAddress) > 0 {
		i -= len(m.AdminAddress)
		copy(dAtA[i:], m.AdminAddress)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.AdminAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindingFingerprint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindingFingerprint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindingFingerprint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentHash) > 0 {
		i -= len(m.PaymentHash)
		copy(dAtA[i:], m.PaymentHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.PaymentHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.SeverityLevel != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.SeverityLevel))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FindingHash) > 0 {
		i -= len(m.FindingHash)
		copy(dAtA[i:], m.FindingHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FindingId) > 0 {
		i -= len(m.FindingId)
		copy(dAtA[i:], m.FindingId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Theorem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Theorem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Theorem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TotalGrant) > 0 {
		for iNdEx := len(m.TotalGrant) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalGrant[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if m.ProofEndTime != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ProofEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ProofEndTime):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintBounty(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x52
	}
	if m.ProofStartTime != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ProofStartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ProofStartTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintBounty(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x4a
	}
	if m.GrantEndTime != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.GrantEndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.GrantEndTime):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintBounty(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x42
	}
	if m.SubmitTime != nil {
		n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.SubmitTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintBounty(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProofId) > 0 {
		i -= len(m.ProofId)
		copy(dAtA[i:], m.ProofId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProofId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Deposit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintBounty(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.Prover) > 0 {
		i -= len(m.Prover)
		copy(dAtA[i:], m.Prover)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Prover)))
		i--
		dAtA[i] = 0x32
	}
	if m.SubmitTime != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.SubmitTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintBounty(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ProofContent) > 0 {
		i -= len(m.ProofContent)
		copy(dAtA[i:], m.ProofContent)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProofContent)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.TheoremId != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.TheoremId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Grant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Grant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Grantor) > 0 {
		i -= len(m.Grantor)
		copy(dAtA[i:], m.Grantor)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Grantor)))
		i--
		dAtA[i] = 0x12
	}
	if m.TheoremsId != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.TheoremsId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProofHashLockPeriod != nil {
		n9, err9 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.ProofHashLockPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.ProofHashLockPeriod):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintBounty(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x22
	}
	if m.ProofPeriod != nil {
		n10, err10 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.ProofPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.ProofPeriod):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintBounty(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxGrantPeriod != nil {
		n11, err11 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.MaxGrantPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxGrantPeriod):])
		if err11 != nil {
			return 0, err11
		}
		i -= n11
		i = encodeVarintBounty(dAtA, i, uint64(n11))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MinGrant) > 0 {
		for iNdEx := len(m.MinGrant) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinGrant[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintBounty(dAtA []byte, offset int, v uint64) int {
	offset -= sovBounty(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Program) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.AdminAddress)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovBounty(uint64(l))
	return n
}

func (m *Finding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.ProofOfConcept)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.SubmitterAddress)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.SeverityLevel != 0 {
		n += 1 + sovBounty(uint64(m.SeverityLevel))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.PaymentHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovBounty(uint64(l))
	return n
}

func (m *ProgramFingerprint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.AdminAddress)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	return n
}

func (m *FindingFingerprint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.SeverityLevel != 0 {
		n += 1 + sovBounty(uint64(m.SeverityLevel))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.PaymentHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	return n
}

func (m *Theorem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBounty(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.ProofId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	if m.SubmitTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.GrantEndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.GrantEndTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.ProofStartTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ProofStartTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.ProofEndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ProofEndTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.TotalGrant) > 0 {
		for _, e := range m.TotalGrant {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	return n
}

func (m *Proof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TheoremId != 0 {
		n += 1 + sovBounty(uint64(m.TheoremId))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.ProofContent)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	if m.SubmitTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Prover)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = m.Deposit.Size()
	n += 1 + l + sovBounty(uint64(l))
	return n
}

func (m *Grant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TheoremsId != 0 {
		n += 1 + sovBounty(uint64(m.TheoremsId))
	}
	l = len(m.Grantor)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MinGrant) > 0 {
		for _, e := range m.MinGrant {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	if m.MaxGrantPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.MaxGrantPeriod)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.ProofPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.ProofPeriod)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.ProofHashLockPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.ProofHashLockPeriod)
		n += 1 + l + sovBounty(uint64(l))
	}
	return n
}

func sovBounty(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBounty(x uint64) (n int) {
	return sovBounty(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Program) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Program: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Program: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProgramStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Finding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfConcept", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofOfConcept = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubmitterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityLevel", wireType)
			}
			m.SeverityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeverityLevel |= SeverityLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FindingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgramFingerprint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgramFingerprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgramFingerprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProgramStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindingFingerprint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindingFingerprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindingFingerprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityLevel", wireType)
			}
			m.SeverityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeverityLevel |= SeverityLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FindingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Theorem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Theorem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Theorem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TheoremStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmitTime == nil {
				m.SubmitTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrantEndTime == nil {
				m.GrantEndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.GrantEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofStartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofStartTime == nil {
				m.ProofStartTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ProofStartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofEndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofEndTime == nil {
				m.ProofEndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ProofEndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGrant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalGrant = append(m.TotalGrant, types1.Coin{})
			if err := m.TotalGrant[len(m.TotalGrant)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheoremId", wireType)
			}
			m.TheoremId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheoremId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofContent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofContent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProofStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmitTime == nil {
				m.SubmitTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Deposit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheoremsId", wireType)
			}
			m.TheoremsId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheoremsId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGrant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinGrant = append(m.MinGrant, types1.Coin{})
			if err := m.MinGrant[len(m.MinGrant)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxGrantPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MaxGrantPeriod == nil {
				m.MaxGrantPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.MaxGrantPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofPeriod == nil {
				m.ProofPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.ProofPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofHashLockPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofHashLockPeriod == nil {
				m.ProofHashLockPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.ProofHashLockPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBounty(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBounty
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBounty
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBounty
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBounty        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBounty          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBounty = fmt.Errorf("proto: unexpected end of group")
)
