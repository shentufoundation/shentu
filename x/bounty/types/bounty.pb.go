// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: shentu/bounty/v1/bounty.proto

package types

import (
	cosmossdk_io_math "cosmossdk.io/math"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/codec/types"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	_ "github.com/cosmos/gogoproto/types"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ProgramStatus int32

const (
	ProgramStatusInactive ProgramStatus = 0
	ProgramStatusActive   ProgramStatus = 1
	ProgramStatusClosed   ProgramStatus = 2
)

var ProgramStatus_name = map[int32]string{
	0: "PROGRAM_STATUS_INACTIVE",
	1: "PROGRAM_STATUS_ACTIVE",
	2: "PROGRAM_STATUS_CLOSED",
}

var ProgramStatus_value = map[string]int32{
	"PROGRAM_STATUS_INACTIVE": 0,
	"PROGRAM_STATUS_ACTIVE":   1,
	"PROGRAM_STATUS_CLOSED":   2,
}

func (x ProgramStatus) String() string {
	return proto.EnumName(ProgramStatus_name, int32(x))
}

func (ProgramStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{0}
}

type SeverityLevel int32

const (
	Unspecified   SeverityLevel = 0
	Critical      SeverityLevel = 1
	High          SeverityLevel = 2
	Medium        SeverityLevel = 3
	Low           SeverityLevel = 4
	Informational SeverityLevel = 5
)

var SeverityLevel_name = map[int32]string{
	0: "SEVERITY_LEVEL_UNSPECIFIED",
	1: "SEVERITY_LEVEL_CRITICAL",
	2: "SEVERITY_LEVEL_HIGH",
	3: "SEVERITY_LEVEL_MEDIUM",
	4: "SEVERITY_LEVEL_LOW",
	5: "SEVERITY_LEVEL_INFORMATIONAL",
}

var SeverityLevel_value = map[string]int32{
	"SEVERITY_LEVEL_UNSPECIFIED":   0,
	"SEVERITY_LEVEL_CRITICAL":      1,
	"SEVERITY_LEVEL_HIGH":          2,
	"SEVERITY_LEVEL_MEDIUM":        3,
	"SEVERITY_LEVEL_LOW":           4,
	"SEVERITY_LEVEL_INFORMATIONAL": 5,
}

func (x SeverityLevel) String() string {
	return proto.EnumName(SeverityLevel_name, int32(x))
}

func (SeverityLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{1}
}

type FindingStatus int32

const (
	FindingStatusSubmitted FindingStatus = 0
	FindingStatusActive    FindingStatus = 1
	FindingStatusConfirmed FindingStatus = 2
	FindingStatusPaid      FindingStatus = 3
	FindingStatusClosed    FindingStatus = 4
)

var FindingStatus_name = map[int32]string{
	0: "FINDING_STATUS_SUBMITTED",
	1: "FINDING_STATUS_ACTIVE",
	2: "FINDING_STATUS_CONFIRMED",
	3: "FINDING_STATUS_PAID",
	4: "FINDING_STATUS_CLOSED",
}

var FindingStatus_value = map[string]int32{
	"FINDING_STATUS_SUBMITTED": 0,
	"FINDING_STATUS_ACTIVE":    1,
	"FINDING_STATUS_CONFIRMED": 2,
	"FINDING_STATUS_PAID":      3,
	"FINDING_STATUS_CLOSED":    4,
}

func (x FindingStatus) String() string {
	return proto.EnumName(FindingStatus_name, int32(x))
}

func (FindingStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{2}
}

type TheoremStatus int32

const (
	// default theorem status.
	TheoremStatus_THEOREM_STATUS_UNSPECIFIED TheoremStatus = 0
	// theorem status during the proof period.
	TheoremStatus_THEOREM_STATUS_PROOF_PERIOD TheoremStatus = 1
	// theorem that has passed.
	TheoremStatus_THEOREM_STATUS_PASSED TheoremStatus = 2
	// theorem that has closed.
	TheoremStatus_THEOREM_STATUS_CLOSED TheoremStatus = 3
)

var TheoremStatus_name = map[int32]string{
	0: "THEOREM_STATUS_UNSPECIFIED",
	1: "THEOREM_STATUS_PROOF_PERIOD",
	2: "THEOREM_STATUS_PASSED",
	3: "THEOREM_STATUS_CLOSED",
}

var TheoremStatus_value = map[string]int32{
	"THEOREM_STATUS_UNSPECIFIED":  0,
	"THEOREM_STATUS_PROOF_PERIOD": 1,
	"THEOREM_STATUS_PASSED":       2,
	"THEOREM_STATUS_CLOSED":       3,
}

func (x TheoremStatus) String() string {
	return proto.EnumName(TheoremStatus_name, int32(x))
}

func (TheoremStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{3}
}

type ProofStatus int32

const (
	// default proof status.
	ProofStatus_PROOF_STATUS_UNSPECIFIED ProofStatus = 0
	// proof status during the creation period.
	ProofStatus_PROOF_STATUS_HASH_LOCK_PERIOD ProofStatus = 1
	// proof status during the upload proof detail period timeout.
	ProofStatus_PROOF_STATUS_HASH_LOCK_TIMEOUT ProofStatus = 2
	// proof status during the upload proof detail period.
	ProofStatus_PROOF_STATUS_HASH_DETAIL_PERIOD ProofStatus = 3
	// theorem that has passed.
	ProofStatus_PROOF_STATUS_PASSED ProofStatus = 4
	// theorem that has failed.
	ProofStatus_PROOF_STATUS_FAILED ProofStatus = 5
)

var ProofStatus_name = map[int32]string{
	0: "PROOF_STATUS_UNSPECIFIED",
	1: "PROOF_STATUS_HASH_LOCK_PERIOD",
	2: "PROOF_STATUS_HASH_LOCK_TIMEOUT",
	3: "PROOF_STATUS_HASH_DETAIL_PERIOD",
	4: "PROOF_STATUS_PASSED",
	5: "PROOF_STATUS_FAILED",
}

var ProofStatus_value = map[string]int32{
	"PROOF_STATUS_UNSPECIFIED":        0,
	"PROOF_STATUS_HASH_LOCK_PERIOD":   1,
	"PROOF_STATUS_HASH_LOCK_TIMEOUT":  2,
	"PROOF_STATUS_HASH_DETAIL_PERIOD": 3,
	"PROOF_STATUS_PASSED":             4,
	"PROOF_STATUS_FAILED":             5,
}

func (x ProofStatus) String() string {
	return proto.EnumName(ProofStatus_name, int32(x))
}

func (ProofStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{4}
}

type Program struct {
	ProgramId string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty" yaml:"program_id"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
	// JSON by ProgramDetail
	Detail       string        `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	AdminAddress string        `protobuf:"bytes,4,opt,name=admin_address,json=adminAddress,proto3" json:"admin_address,omitempty" yaml:"admin_address"`
	Status       ProgramStatus `protobuf:"varint,5,opt,name=status,proto3,enum=shentu.bounty.v1.ProgramStatus" json:"status,omitempty" yaml:"status"`
	CreateTime   time.Time     `protobuf:"bytes,6,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time" yaml:"create_time"`
}

func (m *Program) Reset()         { *m = Program{} }
func (m *Program) String() string { return proto.CompactTextString(m) }
func (*Program) ProtoMessage()    {}
func (*Program) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{0}
}
func (m *Program) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Program) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Program.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Program) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Program.Merge(m, src)
}
func (m *Program) XXX_Size() int {
	return m.Size()
}
func (m *Program) XXX_DiscardUnknown() {
	xxx_messageInfo_Program.DiscardUnknown(m)
}

var xxx_messageInfo_Program proto.InternalMessageInfo

type Finding struct {
	ProgramId      string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty" yaml:"program_id"`
	FindingId      string `protobuf:"bytes,2,opt,name=finding_id,json=findingId,proto3" json:"finding_id,omitempty" yaml:"finding_id"`
	Title          string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Description    string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	ProofOfConcept string `protobuf:"bytes,5,opt,name=proof_of_concept,json=proofOfConcept,proto3" json:"proof_of_concept,omitempty" yaml:"proof_of_concept"`
	// hash(description + proof_of_concept + submitter)
	FindingHash      string        `protobuf:"bytes,6,opt,name=finding_hash,json=findingHash,proto3" json:"finding_hash,omitempty" yaml:"finding_hash"`
	SubmitterAddress string        `protobuf:"bytes,7,opt,name=submitter_address,json=submitterAddress,proto3" json:"submitter_address,omitempty" yaml:"submitter_address"`
	SeverityLevel    SeverityLevel `protobuf:"varint,8,opt,name=severity_level,json=severityLevel,proto3,enum=shentu.bounty.v1.SeverityLevel" json:"severity_level,omitempty" yaml:"severity_level"`
	Status           FindingStatus `protobuf:"varint,9,opt,name=status,proto3,enum=shentu.bounty.v1.FindingStatus" json:"status,omitempty" yaml:"status"`
	// JSON by FindingDetail
	Detail      string    `protobuf:"bytes,10,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	PaymentHash string    `protobuf:"bytes,11,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty" yaml:"payment_hash"`
	CreateTime  time.Time `protobuf:"bytes,12,opt,name=create_time,json=createTime,proto3,stdtime" json:"create_time" yaml:"create_time"`
}

func (m *Finding) Reset()         { *m = Finding{} }
func (m *Finding) String() string { return proto.CompactTextString(m) }
func (*Finding) ProtoMessage()    {}
func (*Finding) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{1}
}
func (m *Finding) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Finding) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Finding.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Finding) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Finding.Merge(m, src)
}
func (m *Finding) XXX_Size() int {
	return m.Size()
}
func (m *Finding) XXX_DiscardUnknown() {
	xxx_messageInfo_Finding.DiscardUnknown(m)
}

var xxx_messageInfo_Finding proto.InternalMessageInfo

type ProgramFingerprint struct {
	ProgramId string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"id" yaml:"id"`
	Name      string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty" yaml:"name"`
	// JSON by ProgramDetail
	Detail       string        `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	AdminAddress string        `protobuf:"bytes,4,opt,name=admin_address,json=adminAddress,proto3" json:"admin_address,omitempty" yaml:"admin_address"`
	Status       ProgramStatus `protobuf:"varint,5,opt,name=status,proto3,enum=shentu.bounty.v1.ProgramStatus" json:"status,omitempty" yaml:"status"`
}

func (m *ProgramFingerprint) Reset()         { *m = ProgramFingerprint{} }
func (m *ProgramFingerprint) String() string { return proto.CompactTextString(m) }
func (*ProgramFingerprint) ProtoMessage()    {}
func (*ProgramFingerprint) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{2}
}
func (m *ProgramFingerprint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProgramFingerprint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProgramFingerprint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProgramFingerprint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProgramFingerprint.Merge(m, src)
}
func (m *ProgramFingerprint) XXX_Size() int {
	return m.Size()
}
func (m *ProgramFingerprint) XXX_DiscardUnknown() {
	xxx_messageInfo_ProgramFingerprint.DiscardUnknown(m)
}

var xxx_messageInfo_ProgramFingerprint proto.InternalMessageInfo

type FindingFingerprint struct {
	ProgramId string `protobuf:"bytes,1,opt,name=program_id,json=programId,proto3" json:"program_id,omitempty" yaml:"program_id"`
	FindingId string `protobuf:"bytes,2,opt,name=finding_id,json=findingId,proto3" json:"id" yaml:"id"`
	Title     string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// hash(description + proof_of_concept + submitter)
	FindingHash   string        `protobuf:"bytes,4,opt,name=finding_hash,json=findingHash,proto3" json:"finding_hash,omitempty" yaml:"finding_hash"`
	SeverityLevel SeverityLevel `protobuf:"varint,5,opt,name=severity_level,json=severityLevel,proto3,enum=shentu.bounty.v1.SeverityLevel" json:"severity_level,omitempty" yaml:"severity_level"`
	Status        FindingStatus `protobuf:"varint,6,opt,name=status,proto3,enum=shentu.bounty.v1.FindingStatus" json:"status,omitempty" yaml:"status"`
	// JSON by FindingDetail
	Detail      string `protobuf:"bytes,7,opt,name=detail,proto3" json:"detail,omitempty" yaml:"detail"`
	PaymentHash string `protobuf:"bytes,8,opt,name=payment_hash,json=paymentHash,proto3" json:"payment_hash,omitempty" yaml:"payment_hash"`
}

func (m *FindingFingerprint) Reset()         { *m = FindingFingerprint{} }
func (m *FindingFingerprint) String() string { return proto.CompactTextString(m) }
func (*FindingFingerprint) ProtoMessage()    {}
func (*FindingFingerprint) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{3}
}
func (m *FindingFingerprint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FindingFingerprint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FindingFingerprint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FindingFingerprint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FindingFingerprint.Merge(m, src)
}
func (m *FindingFingerprint) XXX_Size() int {
	return m.Size()
}
func (m *FindingFingerprint) XXX_DiscardUnknown() {
	xxx_messageInfo_FindingFingerprint.DiscardUnknown(m)
}

var xxx_messageInfo_FindingFingerprint proto.InternalMessageInfo

// Theorem defines the core field members of an openmath theorem.
type Theorem struct {
	// id defines the unique id of the theorem.
	Id uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// title is the title of the theorem
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// description is the description of the theorem
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// code is a summary of the theorem
	Code    string `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	ProofId string `protobuf:"bytes,5,opt,name=proof_id,json=proofId,proto3" json:"proof_id,omitempty"`
	// status defines the theorem status.
	Status TheoremStatus `protobuf:"varint,6,opt,name=status,proto3,enum=shentu.bounty.v1.TheoremStatus" json:"status,omitempty"`
	// submit_time is the time of theorem submission.
	SubmitTime *time.Time `protobuf:"bytes,7,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time,omitempty"`
	EndTime    *time.Time `protobuf:"bytes,8,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	// total_grant is the total grant on the theorem.
	TotalGrant []types1.Coin `protobuf:"bytes,9,rep,name=total_grant,json=totalGrant,proto3" json:"total_grant"`
	// proposer is the address of the theorem submitter
	Proposer string `protobuf:"bytes,10,opt,name=proposer,proto3" json:"proposer,omitempty"`
}

func (m *Theorem) Reset()         { *m = Theorem{} }
func (m *Theorem) String() string { return proto.CompactTextString(m) }
func (*Theorem) ProtoMessage()    {}
func (*Theorem) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{4}
}
func (m *Theorem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Theorem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Theorem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Theorem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Theorem.Merge(m, src)
}
func (m *Theorem) XXX_Size() int {
	return m.Size()
}
func (m *Theorem) XXX_DiscardUnknown() {
	xxx_messageInfo_Theorem.DiscardUnknown(m)
}

var xxx_messageInfo_Theorem proto.InternalMessageInfo

func (m *Theorem) GetId() uint64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Theorem) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Theorem) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Theorem) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Theorem) GetProofId() string {
	if m != nil {
		return m.ProofId
	}
	return ""
}

func (m *Theorem) GetStatus() TheoremStatus {
	if m != nil {
		return m.Status
	}
	return TheoremStatus_THEOREM_STATUS_UNSPECIFIED
}

func (m *Theorem) GetSubmitTime() *time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return nil
}

func (m *Theorem) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Theorem) GetTotalGrant() []types1.Coin {
	if m != nil {
		return m.TotalGrant
	}
	return nil
}

func (m *Theorem) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

type Proof struct {
	TheoremId uint64 `protobuf:"varint,1,opt,name=theorem_id,json=theoremId,proto3" json:"theorem_id,omitempty"`
	// id defines the unique id of the proof.
	Id string `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	// detail is the proof data attached to the theorem stored in ipfs
	Detail string `protobuf:"bytes,3,opt,name=detail,proto3" json:"detail,omitempty"`
	// status defines the theorem status.
	Status ProofStatus `protobuf:"varint,4,opt,name=status,proto3,enum=shentu.bounty.v1.ProofStatus" json:"status,omitempty"`
	// submit_time is the time of proof submission.
	SubmitTime *time.Time `protobuf:"bytes,5,opt,name=submit_time,json=submitTime,proto3,stdtime" json:"submit_time,omitempty"`
	// end_time is the time of proof timeout.
	EndTime *time.Time `protobuf:"bytes,6,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty"`
	// prover is the address of the proof submitter
	Prover string `protobuf:"bytes,7,opt,name=prover,proto3" json:"prover,omitempty"`
	// deposit is the amount deposited by the prover
	Deposit []types1.Coin `protobuf:"bytes,8,rep,name=Deposit,proto3" json:"Deposit"`
}

func (m *Proof) Reset()         { *m = Proof{} }
func (m *Proof) String() string { return proto.CompactTextString(m) }
func (*Proof) ProtoMessage()    {}
func (*Proof) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{5}
}
func (m *Proof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proof.Merge(m, src)
}
func (m *Proof) XXX_Size() int {
	return m.Size()
}
func (m *Proof) XXX_DiscardUnknown() {
	xxx_messageInfo_Proof.DiscardUnknown(m)
}

var xxx_messageInfo_Proof proto.InternalMessageInfo

func (m *Proof) GetTheoremId() uint64 {
	if m != nil {
		return m.TheoremId
	}
	return 0
}

func (m *Proof) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Proof) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

func (m *Proof) GetStatus() ProofStatus {
	if m != nil {
		return m.Status
	}
	return ProofStatus_PROOF_STATUS_UNSPECIFIED
}

func (m *Proof) GetSubmitTime() *time.Time {
	if m != nil {
		return m.SubmitTime
	}
	return nil
}

func (m *Proof) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *Proof) GetProver() string {
	if m != nil {
		return m.Prover
	}
	return ""
}

func (m *Proof) GetDeposit() []types1.Coin {
	if m != nil {
		return m.Deposit
	}
	return nil
}

type ProofHash struct {
	TheoremId uint64 `protobuf:"varint,1,opt,name=theorem_id,json=theoremId,proto3" json:"theorem_id,omitempty"`
	Detail    string `protobuf:"bytes,2,opt,name=detail,proto3" json:"detail,omitempty"`
	Prover    string `protobuf:"bytes,3,opt,name=prover,proto3" json:"prover,omitempty"`
}

func (m *ProofHash) Reset()         { *m = ProofHash{} }
func (m *ProofHash) String() string { return proto.CompactTextString(m) }
func (*ProofHash) ProtoMessage()    {}
func (*ProofHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{6}
}
func (m *ProofHash) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProofHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProofHash.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProofHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProofHash.Merge(m, src)
}
func (m *ProofHash) XXX_Size() int {
	return m.Size()
}
func (m *ProofHash) XXX_DiscardUnknown() {
	xxx_messageInfo_ProofHash.DiscardUnknown(m)
}

var xxx_messageInfo_ProofHash proto.InternalMessageInfo

func (m *ProofHash) GetTheoremId() uint64 {
	if m != nil {
		return m.TheoremId
	}
	return 0
}

func (m *ProofHash) GetDetail() string {
	if m != nil {
		return m.Detail
	}
	return ""
}

func (m *ProofHash) GetProver() string {
	if m != nil {
		return m.Prover
	}
	return ""
}

// Grant defines an amount granted by a grantor to an active theorem.
type Grant struct {
	// theorem_id defines the unique id of the theorem.
	TheoremId uint64 `protobuf:"varint,1,opt,name=theorem_id,json=theoremId,proto3" json:"theorem_id,omitempty"`
	// grantor defines the grant addresses.
	Grantor string `protobuf:"bytes,2,opt,name=grantor,proto3" json:"grantor,omitempty"`
	// amount to be deposited by the grantor.
	Amount []types1.Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *Grant) Reset()         { *m = Grant{} }
func (m *Grant) String() string { return proto.CompactTextString(m) }
func (*Grant) ProtoMessage()    {}
func (*Grant) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{7}
}
func (m *Grant) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Grant) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Grant.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Grant) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Grant.Merge(m, src)
}
func (m *Grant) XXX_Size() int {
	return m.Size()
}
func (m *Grant) XXX_DiscardUnknown() {
	xxx_messageInfo_Grant.DiscardUnknown(m)
}

var xxx_messageInfo_Grant proto.InternalMessageInfo

func (m *Grant) GetTheoremId() uint64 {
	if m != nil {
		return m.TheoremId
	}
	return 0
}

func (m *Grant) GetGrantor() string {
	if m != nil {
		return m.Grantor
	}
	return ""
}

func (m *Grant) GetAmount() []types1.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

// Deposit defines an amount deposited by a depositor for a proof.
type Deposit struct {
	// proof_id defines the unique id of the proof.
	ProofId string `protobuf:"bytes,1,opt,name=proof_id,json=proofId,proto3" json:"proof_id,omitempty"`
	// depositor defines the deposit addresses.
	Depositor string `protobuf:"bytes,2,opt,name=depositor,proto3" json:"depositor,omitempty"`
	// amount to be deposited by the depositor.
	Amount []types1.Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
}

func (m *Deposit) Reset()         { *m = Deposit{} }
func (m *Deposit) String() string { return proto.CompactTextString(m) }
func (*Deposit) ProtoMessage()    {}
func (*Deposit) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{8}
}
func (m *Deposit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Deposit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Deposit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Deposit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Deposit.Merge(m, src)
}
func (m *Deposit) XXX_Size() int {
	return m.Size()
}
func (m *Deposit) XXX_DiscardUnknown() {
	xxx_messageInfo_Deposit.DiscardUnknown(m)
}

var xxx_messageInfo_Deposit proto.InternalMessageInfo

func (m *Deposit) GetProofId() string {
	if m != nil {
		return m.ProofId
	}
	return ""
}

func (m *Deposit) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *Deposit) GetAmount() []types1.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

type Params struct {
	// Minimum grant for a theorem to enter the proof period.
	MinGrant []types1.Coin `protobuf:"bytes,1,rep,name=min_grant,json=minGrant,proto3" json:"min_grant"`
	// Minimum deposit for a proof to enter the proof_hash_lock period.
	MinDeposit []types1.Coin `protobuf:"bytes,2,rep,name=min_deposit,json=minDeposit,proto3" json:"min_deposit"`
	// Duration of the theorem proof period. Initial value: 2 weeks.
	TheoremMaxProofPeriod *time.Duration `protobuf:"bytes,3,opt,name=theorem_max_proof_period,json=theoremMaxProofPeriod,proto3,stdduration" json:"theorem_max_proof_period,omitempty"`
	// Duration of the proof max lock period. 10min
	ProofMaxLockPeriod *time.Duration `protobuf:"bytes,4,opt,name=proof_max_lock_period,json=proofMaxLockPeriod,proto3,stdduration" json:"proof_max_lock_period,omitempty"`
	// rate is the checker rate charged to theorem
	CheckerRate cosmossdk_io_math.LegacyDec `protobuf:"bytes,5,opt,name=checker_rate,json=checkerRate,proto3,customtype=cosmossdk.io/math.LegacyDec" json:"checker_rate"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{9}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMinGrant() []types1.Coin {
	if m != nil {
		return m.MinGrant
	}
	return nil
}

func (m *Params) GetMinDeposit() []types1.Coin {
	if m != nil {
		return m.MinDeposit
	}
	return nil
}

func (m *Params) GetTheoremMaxProofPeriod() *time.Duration {
	if m != nil {
		return m.TheoremMaxProofPeriod
	}
	return nil
}

func (m *Params) GetProofMaxLockPeriod() *time.Duration {
	if m != nil {
		return m.ProofMaxLockPeriod
	}
	return nil
}

type Reward struct {
	Address string                                      `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Reward  github_com_cosmos_cosmos_sdk_types.DecCoins `protobuf:"bytes,2,rep,name=reward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.DecCoins" json:"reward"`
}

func (m *Reward) Reset()         { *m = Reward{} }
func (m *Reward) String() string { return proto.CompactTextString(m) }
func (*Reward) ProtoMessage()    {}
func (*Reward) Descriptor() ([]byte, []int) {
	return fileDescriptor_36e6d679af1b94c6, []int{10}
}
func (m *Reward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Reward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Reward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Reward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reward.Merge(m, src)
}
func (m *Reward) XXX_Size() int {
	return m.Size()
}
func (m *Reward) XXX_DiscardUnknown() {
	xxx_messageInfo_Reward.DiscardUnknown(m)
}

var xxx_messageInfo_Reward proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("shentu.bounty.v1.ProgramStatus", ProgramStatus_name, ProgramStatus_value)
	proto.RegisterEnum("shentu.bounty.v1.SeverityLevel", SeverityLevel_name, SeverityLevel_value)
	proto.RegisterEnum("shentu.bounty.v1.FindingStatus", FindingStatus_name, FindingStatus_value)
	proto.RegisterEnum("shentu.bounty.v1.TheoremStatus", TheoremStatus_name, TheoremStatus_value)
	proto.RegisterEnum("shentu.bounty.v1.ProofStatus", ProofStatus_name, ProofStatus_value)
	proto.RegisterType((*Program)(nil), "shentu.bounty.v1.Program")
	proto.RegisterType((*Finding)(nil), "shentu.bounty.v1.Finding")
	proto.RegisterType((*ProgramFingerprint)(nil), "shentu.bounty.v1.ProgramFingerprint")
	proto.RegisterType((*FindingFingerprint)(nil), "shentu.bounty.v1.FindingFingerprint")
	proto.RegisterType((*Theorem)(nil), "shentu.bounty.v1.Theorem")
	proto.RegisterType((*Proof)(nil), "shentu.bounty.v1.Proof")
	proto.RegisterType((*ProofHash)(nil), "shentu.bounty.v1.ProofHash")
	proto.RegisterType((*Grant)(nil), "shentu.bounty.v1.Grant")
	proto.RegisterType((*Deposit)(nil), "shentu.bounty.v1.Deposit")
	proto.RegisterType((*Params)(nil), "shentu.bounty.v1.Params")
	proto.RegisterType((*Reward)(nil), "shentu.bounty.v1.Reward")
}

func init() { proto.RegisterFile("shentu/bounty/v1/bounty.proto", fileDescriptor_36e6d679af1b94c6) }

var fileDescriptor_36e6d679af1b94c6 = []byte{
	// 1861 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x58, 0xcf, 0x6f, 0xe3, 0xc6,
	0x15, 0x36, 0x25, 0x59, 0x3f, 0x9e, 0xec, 0x8d, 0x3c, 0x5e, 0xad, 0x65, 0xed, 0xae, 0xa8, 0x30,
	0x28, 0xb0, 0xd9, 0x62, 0xa5, 0xda, 0xd9, 0x6e, 0x17, 0xee, 0x0f, 0x40, 0x96, 0xe8, 0x35, 0x1b,
	0xc9, 0x12, 0x28, 0x79, 0xdb, 0xb4, 0x07, 0x81, 0x26, 0x47, 0x32, 0x61, 0x91, 0x14, 0x48, 0xca,
	0x59, 0x1f, 0x7b, 0x29, 0x02, 0x9d, 0xb6, 0xb7, 0xa0, 0x85, 0x80, 0x14, 0xbd, 0x14, 0x05, 0x0a,
	0x14, 0x45, 0xda, 0xbf, 0x21, 0xbd, 0x05, 0x39, 0x15, 0x3d, 0x28, 0xc5, 0xee, 0xa1, 0x45, 0x4f,
	0x85, 0x2e, 0xbd, 0x16, 0x9c, 0x19, 0xc9, 0x22, 0x2d, 0xd7, 0x76, 0xd2, 0x9c, 0x72, 0xd9, 0xd5,
	0xcc, 0xfb, 0xbe, 0xc7, 0xe1, 0xf7, 0xbd, 0xf7, 0x34, 0x32, 0xdc, 0x77, 0x8e, 0xb1, 0xe9, 0x0e,
	0x8a, 0x47, 0xd6, 0xc0, 0x74, 0xcf, 0x8a, 0xa7, 0x5b, 0xec, 0x53, 0xa1, 0x6f, 0x5b, 0xae, 0x85,
	0x52, 0x34, 0x5c, 0x60, 0x9b, 0xa7, 0x5b, 0xd9, 0xdb, 0x5d, 0xab, 0x6b, 0x91, 0x60, 0xd1, 0xfb,
	0x44, 0x71, 0x59, 0xbe, 0x6b, 0x59, 0xdd, 0x1e, 0x2e, 0x92, 0xd5, 0xd1, 0xa0, 0x53, 0x74, 0x75,
	0x03, 0x3b, 0xae, 0x62, 0xf4, 0x19, 0x20, 0xa7, 0x5a, 0x8e, 0x61, 0x39, 0xc5, 0x23, 0xc5, 0xc1,
	0xc5, 0xd3, 0xad, 0x23, 0xec, 0x2a, 0x5b, 0x45, 0xd5, 0xd2, 0x4d, 0x16, 0xdf, 0xa4, 0xf1, 0x36,
	0xcd, 0x4c, 0x17, 0xd3, 0x50, 0x30, 0xb7, 0x62, 0x9e, 0x4d, 0xb3, 0x06, 0x43, 0xda, 0xc0, 0x56,
	0x5c, 0xdd, 0x9a, 0x66, 0x5d, 0x53, 0x0c, 0xdd, 0xb4, 0x8a, 0xe4, 0x5f, 0xba, 0x25, 0xfc, 0x2c,
	0x0c, 0xb1, 0x86, 0x6d, 0x75, 0x6d, 0xc5, 0x40, 0x8f, 0x01, 0xfa, 0xf4, 0x63, 0x5b, 0xd7, 0x32,
	0x5c, 0x9e, 0x7b, 0x90, 0xd8, 0x4d, 0x4f, 0xc6, 0xfc, 0xda, 0x99, 0x62, 0xf4, 0x76, 0x84, 0xf3,
	0x98, 0x20, 0x27, 0xd8, 0x42, 0xd2, 0xd0, 0x5b, 0x10, 0x31, 0x15, 0x03, 0x67, 0x42, 0x04, 0xff,
	0xc6, 0x64, 0xcc, 0x27, 0x29, 0xde, 0xdb, 0x15, 0x64, 0x12, 0x44, 0x6f, 0x43, 0x54, 0xc3, 0xae,
	0xa2, 0xf7, 0x32, 0x61, 0x02, 0x5b, 0x9b, 0x8c, 0xf9, 0x55, 0x0a, 0xa3, 0xfb, 0x82, 0xcc, 0x00,
	0xe8, 0xfb, 0xb0, 0xaa, 0x68, 0x86, 0x6e, 0xb6, 0x15, 0x4d, 0xb3, 0xb1, 0xe3, 0x64, 0x22, 0x84,
	0x91, 0x99, 0x8c, 0xf9, 0xdb, 0x94, 0xe1, 0x0b, 0x0b, 0xf2, 0x0a, 0x59, 0x97, 0xe8, 0x12, 0xfd,
	0x10, 0xa2, 0x8e, 0xab, 0xb8, 0x03, 0x27, 0xb3, 0x9c, 0xe7, 0x1e, 0xdc, 0xda, 0xe6, 0x0b, 0x41,
	0xcf, 0x0a, 0xec, 0x7d, 0x9b, 0x04, 0x36, 0x7f, 0x14, 0x4a, 0x14, 0x64, 0x96, 0x01, 0xfd, 0x14,
	0x92, 0xaa, 0x8d, 0x15, 0x17, 0xb7, 0x3d, 0xff, 0x32, 0xd1, 0x3c, 0xf7, 0x20, 0xb9, 0x9d, 0x2d,
	0x50, 0x95, 0x0b, 0x53, 0x95, 0x0b, 0xad, 0xa9, 0xb9, 0xbb, 0xb9, 0x4f, 0xc6, 0xfc, 0xd2, 0x64,
	0xcc, 0x23, 0x9a, 0x6f, 0x8e, 0x2c, 0xbc, 0xfc, 0x9c, 0xe7, 0x64, 0xa0, 0x3b, 0x1e, 0x61, 0x27,
	0xfe, 0xc1, 0x47, 0xfc, 0xd2, 0x3f, 0x3f, 0xe2, 0x97, 0x84, 0x97, 0x51, 0x88, 0xed, 0xe9, 0xa6,
	0xa6, 0x9b, 0xdd, 0x2f, 0xe8, 0xc1, 0x63, 0x80, 0x0e, 0x4d, 0xe0, 0xb1, 0x42, 0x41, 0xd6, 0x79,
	0x4c, 0x90, 0x13, 0x6c, 0x21, 0x69, 0xe8, 0x36, 0x2c, 0xbb, 0xba, 0xdb, 0xc3, 0xd4, 0x13, 0x99,
	0x2e, 0xd0, 0x53, 0x48, 0x6a, 0xd8, 0x51, 0x6d, 0xbd, 0xef, 0x55, 0x0e, 0x53, 0xff, 0xce, 0xf9,
	0x4b, 0xcd, 0x05, 0x05, 0x79, 0x1e, 0x8a, 0x44, 0x48, 0xf5, 0x6d, 0xcb, 0xea, 0xb4, 0xad, 0x4e,
	0x5b, 0xb5, 0x4c, 0x15, 0xf7, 0x5d, 0x62, 0x42, 0x62, 0xf7, 0xee, 0x64, 0xcc, 0x6f, 0xcc, 0xde,
	0xc0, 0x87, 0x10, 0xe4, 0x5b, 0x64, 0xab, 0xde, 0x29, 0xd3, 0x0d, 0xb4, 0x03, 0x2b, 0xd3, 0x03,
	0x1f, 0x2b, 0xce, 0x31, 0x91, 0x3d, 0xb1, 0xbb, 0x31, 0x19, 0xf3, 0xeb, 0xfe, 0xd7, 0xf1, 0xa2,
	0x82, 0x9c, 0x64, 0xcb, 0x7d, 0xc5, 0x39, 0x46, 0x12, 0xac, 0x39, 0x83, 0x23, 0x43, 0x77, 0x5d,
	0x6c, 0xcf, 0x0a, 0x28, 0x46, 0x12, 0xdc, 0x9b, 0x8c, 0xf9, 0x0c, 0xf3, 0x39, 0x08, 0x11, 0xe4,
	0xd4, 0x6c, 0x6f, 0x5a, 0x48, 0x0a, 0xdc, 0x72, 0xf0, 0x29, 0xb6, 0x75, 0xf7, 0xac, 0xdd, 0xc3,
	0xa7, 0xb8, 0x97, 0x89, 0x5f, 0x56, 0x50, 0x4d, 0x86, 0xab, 0x7a, 0xb0, 0xdd, 0xcd, 0xc9, 0x98,
	0x4f, 0xb3, 0x07, 0xf9, 0x12, 0x08, 0xf2, 0xaa, 0x33, 0x8f, 0x9c, 0xab, 0xd5, 0xc4, 0x65, 0xa9,
	0x59, 0x5d, 0x5c, 0x5d, 0xab, 0xe7, 0x1d, 0x06, 0x57, 0x75, 0xd8, 0x0e, 0xac, 0xf4, 0x95, 0x33,
	0x03, 0x9b, 0x2e, 0x15, 0x38, 0x19, 0x14, 0x78, 0x3e, 0x2a, 0xc8, 0x49, 0xb6, 0x24, 0x02, 0x07,
	0x5a, 0x62, 0xe5, 0x2b, 0x6a, 0x89, 0xdf, 0x87, 0x00, 0xb1, 0x36, 0xdd, 0xd3, 0xcd, 0x2e, 0xb6,
	0xfb, 0xb6, 0x6e, 0xba, 0x68, 0x7b, 0x41, 0x77, 0xac, 0xff, 0x6b, 0xcc, 0x87, 0x74, 0x6d, 0x32,
	0xe6, 0x13, 0xf4, 0x11, 0x5f, 0x9b, 0xf9, 0x34, 0xa7, 0xd7, 0xbf, 0xc3, 0x80, 0x58, 0xa9, 0xcc,
	0xeb, 0xf5, 0xc5, 0xa6, 0xc9, 0xf6, 0x82, 0x69, 0xb2, 0x58, 0xe5, 0xab, 0x66, 0x49, 0xb0, 0x95,
	0x23, 0x37, 0x68, 0xe5, 0x8b, 0xfd, 0xb7, 0xfc, 0xd5, 0xf5, 0x5f, 0xf4, 0xff, 0xd8, 0x7f, 0xb1,
	0x9b, 0xf6, 0x5f, 0xfc, 0xfa, 0xfd, 0x37, 0x67, 0xf9, 0x9f, 0xc3, 0x10, 0x6b, 0x1d, 0x63, 0xcb,
	0xc6, 0x06, 0xba, 0x05, 0x21, 0xe6, 0x6f, 0x44, 0x0e, 0xe9, 0x73, 0x6e, 0x84, 0xe6, 0xdd, 0xc8,
	0xfb, 0x27, 0x3b, 0x75, 0xca, 0x37, 0xc1, 0x11, 0x44, 0x54, 0x4b, 0xc3, 0xd4, 0x27, 0x99, 0x7c,
	0x46, 0x9b, 0x10, 0xa7, 0x33, 0x5b, 0xd7, 0xe8, 0x34, 0x97, 0x63, 0x64, 0x2d, 0x69, 0xe8, 0x3b,
	0x57, 0xeb, 0xc7, 0x4e, 0x48, 0xf5, 0x9b, 0x89, 0x55, 0x82, 0x24, 0x9d, 0xb7, 0x74, 0x8a, 0xc4,
	0xae, 0x9c, 0x22, 0x11, 0x3a, 0x2b, 0x28, 0xc9, 0xdb, 0x46, 0xdf, 0x85, 0x38, 0x36, 0x35, 0xca,
	0x8f, 0x5f, 0x93, 0x1f, 0xc3, 0xa6, 0x46, 0xc8, 0x22, 0x24, 0x5d, 0xcb, 0x55, 0x7a, 0xed, 0xae,
	0xad, 0x98, 0x6e, 0x26, 0x91, 0x0f, 0x3f, 0x48, 0x6e, 0x6f, 0x16, 0xd8, 0x3d, 0xcb, 0xbb, 0x94,
	0x15, 0xd8, 0xa5, 0xac, 0x50, 0xb6, 0x74, 0x73, 0x37, 0xe1, 0x0d, 0xb1, 0xdf, 0xfe, 0xe3, 0x0f,
	0x0f, 0x39, 0x19, 0x08, 0xf1, 0x99, 0xc7, 0x43, 0x8f, 0x89, 0x34, 0x7d, 0xcb, 0xc1, 0x36, 0x9b,
	0xba, 0x99, 0xcf, 0x3e, 0x7e, 0x74, 0x9b, 0xa5, 0x61, 0x1d, 0xdf, 0x74, 0x6d, 0xdd, 0xec, 0xca,
	0x33, 0xa4, 0xf0, 0x9f, 0x10, 0x2c, 0x37, 0x3c, 0x05, 0xd1, 0x7d, 0x00, 0x97, 0xea, 0xd3, 0x9e,
	0xd9, 0x97, 0x60, 0x3b, 0x92, 0xc6, 0x5c, 0xa5, 0x16, 0x7a, 0xae, 0xde, 0xf1, 0x0f, 0xa9, 0x59,
	0x3d, 0x7d, 0x7b, 0x66, 0x43, 0x84, 0xd8, 0x70, 0x7f, 0xe1, 0x48, 0xb1, 0x3a, 0xff, 0xdb, 0x84,
	0xe5, 0x2f, 0x69, 0x42, 0xf4, 0xa6, 0x26, 0x7c, 0x0b, 0xa2, 0x7d, 0xdb, 0x3a, 0xc5, 0x36, 0xeb,
	0x98, 0xcb, 0xb5, 0x63, 0x38, 0xf4, 0x03, 0x88, 0x55, 0x70, 0xdf, 0x72, 0x74, 0x37, 0x13, 0xbf,
	0x81, 0x65, 0x53, 0x92, 0xe0, 0x42, 0x82, 0x08, 0x41, 0xe6, 0xcb, 0x15, 0xe2, 0x9f, 0x8b, 0x1d,
	0xf2, 0x89, 0x7d, 0x7e, 0xea, 0xf0, 0xf5, 0x4e, 0x2d, 0x7c, 0xc8, 0xc1, 0x32, 0xad, 0x97, 0x2b,
	0x1e, 0xb9, 0x0d, 0x31, 0x52, 0x8f, 0x96, 0xcd, 0x86, 0xee, 0xe5, 0xb9, 0xa7, 0x40, 0xf4, 0x3d,
	0x88, 0x2a, 0x86, 0x67, 0x73, 0x26, 0x7c, 0x03, 0x45, 0x18, 0x47, 0xf8, 0x25, 0x37, 0x53, 0xd4,
	0xd7, 0xe7, 0x9c, 0xbf, 0xcf, 0x9f, 0x40, 0x42, 0xa3, 0xa8, 0x6b, 0x1c, 0xed, 0x1c, 0xfa, 0x25,
	0x0f, 0xf7, 0xab, 0x30, 0x44, 0x1b, 0x8a, 0xad, 0x18, 0x5e, 0xa9, 0x26, 0xbc, 0xaf, 0x54, 0xda,
	0xad, 0xdc, 0x0d, 0x72, 0xc5, 0x0d, 0xdd, 0xa4, 0xda, 0x8b, 0x90, 0xf4, 0x52, 0xb0, 0xc3, 0x65,
	0x42, 0x37, 0x69, 0x79, 0x43, 0x37, 0xa7, 0x2a, 0xfd, 0x18, 0x32, 0x53, 0x0b, 0x0d, 0xe5, 0x45,
	0x9b, 0x2a, 0xd6, 0xc7, 0xb6, 0x6e, 0x69, 0xa4, 0x20, 0xbc, 0x9c, 0xc1, 0x0e, 0xa8, 0xb0, 0x5f,
	0x61, 0xbb, 0x91, 0x0f, 0xbd, 0x06, 0x48, 0xb3, 0x04, 0x35, 0xe5, 0x05, 0xa9, 0xc6, 0x06, 0x61,
	0x23, 0x19, 0xd2, 0x34, 0x9b, 0x97, 0xb7, 0x67, 0xa9, 0x27, 0xd3, 0xb4, 0x91, 0xeb, 0xa5, 0x45,
	0x84, 0x5d, 0x53, 0x5e, 0x54, 0x2d, 0xf5, 0x84, 0xe5, 0x7c, 0x0f, 0x56, 0xd4, 0x63, 0xac, 0x9e,
	0x60, 0xbb, 0x6d, 0x2b, 0x2e, 0x66, 0xb7, 0xf1, 0x27, 0xde, 0xab, 0xfd, 0x6d, 0xcc, 0xdf, 0xa5,
	0x2f, 0xef, 0x68, 0x27, 0x05, 0xdd, 0x2a, 0x1a, 0x8a, 0x7b, 0x5c, 0xa8, 0xe2, 0xae, 0xa2, 0x9e,
	0x55, 0xb0, 0xfa, 0xd9, 0xc7, 0x8f, 0x80, 0x69, 0x53, 0xc1, 0x2a, 0xd5, 0x21, 0xc9, 0x72, 0xc9,
	0x8a, 0x8b, 0x85, 0x3f, 0x72, 0x10, 0x95, 0xf1, 0xfb, 0x8a, 0x4d, 0xea, 0x76, 0x7a, 0x17, 0xe2,
	0xae, 0xaa, 0x5b, 0x06, 0x44, 0x26, 0x44, 0x6d, 0xc2, 0x66, 0x4e, 0xdc, 0x5b, 0xe8, 0x44, 0x05,
	0xab, 0xc4, 0x8c, 0xa7, 0xde, 0x89, 0x7f, 0xf7, 0x39, 0xff, 0xcd, 0xae, 0xee, 0x1e, 0x0f, 0x8e,
	0x0a, 0xaa, 0x65, 0xb0, 0x1f, 0xc5, 0xec, 0xbf, 0x47, 0x8e, 0x76, 0x52, 0x74, 0xcf, 0xfa, 0xd8,
	0x99, 0x72, 0x1c, 0x56, 0x4c, 0xf4, 0x29, 0x3b, 0x11, 0xef, 0x7b, 0xf3, 0xe1, 0x9f, 0x38, 0x58,
	0xf5, 0xdd, 0xae, 0xd0, 0x13, 0xd8, 0x68, 0xc8, 0xf5, 0x67, 0x72, 0xa9, 0xd6, 0x6e, 0xb6, 0x4a,
	0xad, 0xc3, 0x66, 0x5b, 0x3a, 0x28, 0x95, 0x5b, 0xd2, 0x73, 0x31, 0xb5, 0x94, 0xdd, 0x1c, 0x8e,
	0xf2, 0x69, 0x1f, 0x5e, 0x32, 0x15, 0xd5, 0xd5, 0x4f, 0x31, 0xda, 0x86, 0x74, 0x80, 0xc7, 0x58,
	0x5c, 0x76, 0x63, 0x38, 0xca, 0xaf, 0xfb, 0x58, 0xa5, 0xcb, 0x38, 0xe5, 0x6a, 0xbd, 0x29, 0x56,
	0x52, 0xa1, 0x05, 0x9c, 0x72, 0xcf, 0x72, 0xb0, 0x96, 0x8d, 0x7c, 0xf0, 0x9b, 0xdc, 0xd2, 0xc3,
	0x5f, 0x84, 0x60, 0xd5, 0x77, 0xc9, 0x41, 0x45, 0xc8, 0x36, 0xc5, 0xe7, 0xa2, 0x2c, 0xb5, 0xde,
	0x6b, 0x57, 0xc5, 0xe7, 0x62, 0xb5, 0x7d, 0x78, 0xd0, 0x6c, 0x88, 0x65, 0x69, 0x4f, 0x12, 0x2b,
	0xa9, 0xa5, 0xec, 0x1b, 0xc3, 0x51, 0x3e, 0x79, 0x68, 0x3a, 0x7d, 0xac, 0xea, 0x1d, 0x1d, 0x6b,
	0xe8, 0x6d, 0xd8, 0x08, 0x10, 0xca, 0xb2, 0xd4, 0x92, 0xca, 0xa5, 0x6a, 0x8a, 0xcb, 0xae, 0x0c,
	0x47, 0xf9, 0x78, 0xd9, 0xd6, 0x5d, 0x5d, 0x55, 0x7a, 0xe8, 0x4d, 0x58, 0x0f, 0x40, 0xf7, 0xa5,
	0x67, 0xfb, 0xa9, 0x50, 0x36, 0x3e, 0x1c, 0xe5, 0x23, 0xfb, 0x7a, 0xf7, 0x18, 0x7d, 0x03, 0xd2,
	0x01, 0x48, 0x4d, 0xac, 0x48, 0x87, 0xb5, 0x54, 0x38, 0x0b, 0xc3, 0x51, 0x3e, 0x5a, 0xc3, 0x9a,
	0x3e, 0x30, 0x10, 0x0f, 0x28, 0x00, 0xab, 0xd6, 0x7f, 0x94, 0x8a, 0x64, 0x63, 0xc3, 0x51, 0x3e,
	0x5c, 0xb5, 0xde, 0x47, 0xef, 0xc0, 0xbd, 0x00, 0x40, 0x3a, 0xd8, 0xab, 0xcb, 0xb5, 0x52, 0x4b,
	0xaa, 0x1f, 0x94, 0xaa, 0xa9, 0xe5, 0xec, 0xda, 0x70, 0x94, 0x5f, 0x95, 0xcc, 0x8e, 0x65, 0x1b,
	0xa4, 0xda, 0x95, 0x1e, 0xd3, 0xe4, 0xd7, 0x21, 0x58, 0xf5, 0xdd, 0xce, 0xd0, 0x53, 0xc8, 0xec,
	0x49, 0x07, 0x15, 0xe9, 0xe0, 0xd9, 0x54, 0xdf, 0xe6, 0xe1, 0x6e, 0x4d, 0x6a, 0xb5, 0x88, 0x22,
	0xd9, 0xe1, 0x28, 0x7f, 0xc7, 0x47, 0x68, 0xb2, 0x9f, 0x7c, 0x5e, 0x05, 0xa7, 0x03, 0x4c, 0xbf,
	0x9b, 0x3e, 0x1a, 0x73, 0xf3, 0xe2, 0xd3, 0xca, 0xf5, 0x83, 0x3d, 0x49, 0xae, 0x11, 0x43, 0x2f,
	0x3e, 0xad, 0x6c, 0x99, 0x1d, 0xdd, 0x36, 0xb0, 0x86, 0x0a, 0xb0, 0x1e, 0x60, 0x36, 0x4a, 0x52,
	0x25, 0x15, 0xce, 0xa6, 0x87, 0xa3, 0xfc, 0x9a, 0x8f, 0xd4, 0x50, 0xf4, 0x45, 0xa7, 0x63, 0x75,
	0x13, 0x59, 0x70, 0x3a, 0x5f, 0xdd, 0xfc, 0x9c, 0x83, 0x55, 0xdf, 0x0d, 0x0c, 0xe5, 0x20, 0xdb,
	0xda, 0x17, 0xeb, 0xb2, 0x38, 0xab, 0x41, 0x5f, 0xdd, 0x20, 0x1e, 0xee, 0x06, 0xe2, 0x0d, 0xb9,
	0x5e, 0xdf, 0x6b, 0x37, 0x44, 0x59, 0xaa, 0x57, 0x52, 0x1c, 0xda, 0x84, 0x74, 0x10, 0x50, 0x6a,
	0x92, 0x22, 0x5e, 0x10, 0x62, 0xe7, 0x0c, 0x3f, 0xfc, 0x0b, 0x07, 0xc9, 0xb9, 0x3b, 0x08, 0xba,
	0x07, 0x19, 0x9a, 0x77, 0xe1, 0x21, 0xde, 0x84, 0xfb, 0xbe, 0xe8, 0x7e, 0xa9, 0xb9, 0xdf, 0xae,
	0xd6, 0xcb, 0xef, 0x9e, 0x1f, 0x43, 0x80, 0xdc, 0x25, 0x90, 0x96, 0x54, 0x13, 0xeb, 0x87, 0xad,
	0x54, 0x08, 0xbd, 0x05, 0xfc, 0x45, 0x4c, 0x45, 0x6c, 0x95, 0xa4, 0xea, 0x34, 0x51, 0x18, 0x6d,
	0xc0, 0xba, 0x0f, 0xc4, 0xde, 0x26, 0x72, 0x21, 0xb0, 0x57, 0x92, 0xaa, 0x62, 0x25, 0xb5, 0xbc,
	0xfb, 0xee, 0x27, 0xaf, 0x72, 0xdc, 0xa7, 0xaf, 0x72, 0xdc, 0xdf, 0x5f, 0xe5, 0xb8, 0x97, 0xaf,
	0x73, 0x4b, 0x9f, 0xbe, 0xce, 0x2d, 0xfd, 0xf5, 0x75, 0x6e, 0xe9, 0x27, 0x5b, 0x73, 0xe3, 0x89,
	0x5e, 0xc1, 0x3a, 0xd6, 0xc0, 0xd4, 0x48, 0xdd, 0xb2, 0x8d, 0xe2, 0x8b, 0xe9, 0xdf, 0x16, 0xc9,
	0xb4, 0x3a, 0x8a, 0x92, 0x71, 0xfe, 0xce, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x5b, 0x79, 0x8a,
	0x53, 0x79, 0x14, 0x00, 0x00,
}

func (m *Program) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Program) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Program) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintBounty(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x32
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AdminAddress) > 0 {
		i -= len(m.AdminAddress)
		copy(dAtA[i:], m.AdminAddress)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.AdminAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Finding) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Finding) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Finding) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreateTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintBounty(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x62
	if len(m.PaymentHash) > 0 {
		i -= len(m.PaymentHash)
		copy(dAtA[i:], m.PaymentHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.PaymentHash)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x52
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.SeverityLevel != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.SeverityLevel))
		i--
		dAtA[i] = 0x40
	}
	if len(m.SubmitterAddress) > 0 {
		i -= len(m.SubmitterAddress)
		copy(dAtA[i:], m.SubmitterAddress)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.SubmitterAddress)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.FindingHash) > 0 {
		i -= len(m.FindingHash)
		copy(dAtA[i:], m.FindingHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProofOfConcept) > 0 {
		i -= len(m.ProofOfConcept)
		copy(dAtA[i:], m.ProofOfConcept)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProofOfConcept)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FindingId) > 0 {
		i -= len(m.FindingId)
		copy(dAtA[i:], m.FindingId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProgramFingerprint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgramFingerprint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProgramFingerprint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AdminAddress) > 0 {
		i -= len(m.AdminAddress)
		copy(dAtA[i:], m.AdminAddress)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.AdminAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FindingFingerprint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FindingFingerprint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FindingFingerprint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PaymentHash) > 0 {
		i -= len(m.PaymentHash)
		copy(dAtA[i:], m.PaymentHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.PaymentHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.SeverityLevel != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.SeverityLevel))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FindingHash) > 0 {
		i -= len(m.FindingHash)
		copy(dAtA[i:], m.FindingHash)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FindingId) > 0 {
		i -= len(m.FindingId)
		copy(dAtA[i:], m.FindingId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.FindingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProgramId) > 0 {
		i -= len(m.ProgramId)
		copy(dAtA[i:], m.ProgramId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProgramId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Theorem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Theorem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Theorem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.TotalGrant) > 0 {
		for iNdEx := len(m.TotalGrant) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalGrant[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.EndTime != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintBounty(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x42
	}
	if m.SubmitTime != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.SubmitTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintBounty(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ProofId) > 0 {
		i -= len(m.ProofId)
		copy(dAtA[i:], m.ProofId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProofId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Deposit) > 0 {
		for iNdEx := len(m.Deposit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Deposit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.Prover) > 0 {
		i -= len(m.Prover)
		copy(dAtA[i:], m.Prover)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Prover)))
		i--
		dAtA[i] = 0x3a
	}
	if m.EndTime != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintBounty(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x32
	}
	if m.SubmitTime != nil {
		n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.SubmitTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintBounty(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x2a
	}
	if m.Status != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x12
	}
	if m.TheoremId != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.TheoremId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProofHash) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProofHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProofHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Prover) > 0 {
		i -= len(m.Prover)
		copy(dAtA[i:], m.Prover)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Prover)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Detail) > 0 {
		i -= len(m.Detail)
		copy(dAtA[i:], m.Detail)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Detail)))
		i--
		dAtA[i] = 0x12
	}
	if m.TheoremId != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.TheoremId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Grant) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grant) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Grant) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Grantor) > 0 {
		i -= len(m.Grantor)
		copy(dAtA[i:], m.Grantor)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Grantor)))
		i--
		dAtA[i] = 0x12
	}
	if m.TheoremId != 0 {
		i = encodeVarintBounty(dAtA, i, uint64(m.TheoremId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Deposit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Deposit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Deposit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProofId) > 0 {
		i -= len(m.ProofId)
		copy(dAtA[i:], m.ProofId)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.ProofId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size := m.CheckerRate.Size()
		i -= size
		if _, err := m.CheckerRate.MarshalTo(dAtA[i:]); err != nil {
			return 0, err
		}
		i = encodeVarintBounty(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if m.ProofMaxLockPeriod != nil {
		n7, err7 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.ProofMaxLockPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.ProofMaxLockPeriod):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintBounty(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x22
	}
	if m.TheoremMaxProofPeriod != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdDurationMarshalTo(*m.TheoremMaxProofPeriod, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.TheoremMaxProofPeriod):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintBounty(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MinDeposit) > 0 {
		for iNdEx := len(m.MinDeposit) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinDeposit[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.MinGrant) > 0 {
		for iNdEx := len(m.MinGrant) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MinGrant[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Reward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Reward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reward) > 0 {
		for iNdEx := len(m.Reward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Reward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintBounty(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintBounty(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintBounty(dAtA []byte, offset int, v uint64) int {
	offset -= sovBounty(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Program) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.AdminAddress)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovBounty(uint64(l))
	return n
}

func (m *Finding) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.ProofOfConcept)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.SubmitterAddress)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.SeverityLevel != 0 {
		n += 1 + sovBounty(uint64(m.SeverityLevel))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.PaymentHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreateTime)
	n += 1 + l + sovBounty(uint64(l))
	return n
}

func (m *ProgramFingerprint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.AdminAddress)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	return n
}

func (m *FindingFingerprint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProgramId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.FindingHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.SeverityLevel != 0 {
		n += 1 + sovBounty(uint64(m.SeverityLevel))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.PaymentHash)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	return n
}

func (m *Theorem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovBounty(uint64(m.Id))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.ProofId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	if m.SubmitTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.TotalGrant) > 0 {
		for _, e := range m.TotalGrant {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	return n
}

func (m *Proof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TheoremId != 0 {
		n += 1 + sovBounty(uint64(m.TheoremId))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovBounty(uint64(m.Status))
	}
	if m.SubmitTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SubmitTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Prover)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.Deposit) > 0 {
		for _, e := range m.Deposit {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	return n
}

func (m *ProofHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TheoremId != 0 {
		n += 1 + sovBounty(uint64(m.TheoremId))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Prover)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	return n
}

func (m *Grant) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TheoremId != 0 {
		n += 1 + sovBounty(uint64(m.TheoremId))
	}
	l = len(m.Grantor)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	return n
}

func (m *Deposit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProofId)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MinGrant) > 0 {
		for _, e := range m.MinGrant {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	if len(m.MinDeposit) > 0 {
		for _, e := range m.MinDeposit {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	if m.TheoremMaxProofPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.TheoremMaxProofPeriod)
		n += 1 + l + sovBounty(uint64(l))
	}
	if m.ProofMaxLockPeriod != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdDuration(*m.ProofMaxLockPeriod)
		n += 1 + l + sovBounty(uint64(l))
	}
	l = m.CheckerRate.Size()
	n += 1 + l + sovBounty(uint64(l))
	return n
}

func (m *Reward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovBounty(uint64(l))
	}
	if len(m.Reward) > 0 {
		for _, e := range m.Reward {
			l = e.Size()
			n += 1 + l + sovBounty(uint64(l))
		}
	}
	return n
}

func sovBounty(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozBounty(x uint64) (n int) {
	return sovBounty(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Program) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Program: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Program: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProgramStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Finding) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finding: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finding: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofOfConcept", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofOfConcept = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubmitterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityLevel", wireType)
			}
			m.SeverityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeverityLevel |= SeverityLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FindingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreateTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgramFingerprint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgramFingerprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgramFingerprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdminAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProgramStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FindingFingerprint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FindingFingerprint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FindingFingerprint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgramId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProgramId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FindingHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FindingHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeverityLevel", wireType)
			}
			m.SeverityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeverityLevel |= SeverityLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FindingStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Theorem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Theorem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Theorem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TheoremStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmitTime == nil {
				m.SubmitTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGrant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalGrant = append(m.TotalGrant, types1.Coin{})
			if err := m.TotalGrant[len(m.TotalGrant)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheoremId", wireType)
			}
			m.TheoremId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheoremId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ProofStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SubmitTime == nil {
				m.SubmitTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.SubmitTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Deposit = append(m.Deposit, types1.Coin{})
			if err := m.Deposit[len(m.Deposit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProofHash) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProofHash: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProofHash: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheoremId", wireType)
			}
			m.TheoremId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheoremId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prover", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prover = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Grant) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grant: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grant: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheoremId", wireType)
			}
			m.TheoremId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TheoremId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Grantor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Grantor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Deposit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Deposit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Deposit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProofId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types1.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinGrant", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinGrant = append(m.MinGrant, types1.Coin{})
			if err := m.MinGrant[len(m.MinGrant)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDeposit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinDeposit = append(m.MinDeposit, types1.Coin{})
			if err := m.MinDeposit[len(m.MinDeposit)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TheoremMaxProofPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TheoremMaxProofPeriod == nil {
				m.TheoremMaxProofPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.TheoremMaxProofPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProofMaxLockPeriod", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProofMaxLockPeriod == nil {
				m.ProofMaxLockPeriod = new(time.Duration)
			}
			if err := github_com_cosmos_gogoproto_types.StdDurationUnmarshal(m.ProofMaxLockPeriod, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckerRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckerRate.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthBounty
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthBounty
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reward = append(m.Reward, types1.DecCoin{})
			if err := m.Reward[len(m.Reward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipBounty(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthBounty
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipBounty(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowBounty
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowBounty
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthBounty
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupBounty
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthBounty
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthBounty        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowBounty          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupBounty = fmt.Errorf("proto: unexpected end of group")
)
